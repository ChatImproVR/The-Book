<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="development_environment.html"><strong aria-hidden="true">3.</strong> Development Environment</a></li><li class="chapter-item expanded "><a href="Core_Concepts/core_concepts.html"><strong aria-hidden="true">4.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Core_Concepts/plugin.html"><strong aria-hidden="true">4.1.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="Core_Concepts/wasm.html"><strong aria-hidden="true">4.2.</strong> Webassembly</a></li><li class="chapter-item expanded "><a href="Core_Concepts/entity_component_system.html"><strong aria-hidden="true">4.3.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="Core_Concepts/pub_sub.html"><strong aria-hidden="true">4.4.</strong> Pub/Sub channels</a></li><li class="chapter-item expanded "><a href="Core_Concepts/client_and_server.html"><strong aria-hidden="true">4.5.</strong> Client and Server</a></li><li class="chapter-item expanded "><a href="Core_Concepts/crates.html"><strong aria-hidden="true">4.6.</strong> Crates</a></li><li class="chapter-item expanded "><a href="Core_Concepts/names.html"><strong aria-hidden="true">4.7.</strong> Names</a></li><li class="chapter-item expanded "><a href="Core_Concepts/coordinate_system.html"><strong aria-hidden="true">4.8.</strong> Coordinate system</a></li><li class="chapter-item expanded "><a href="Core_Concepts/rendering.html"><strong aria-hidden="true">4.9.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="Core_Concepts/api_docs.html"><strong aria-hidden="true">4.10.</strong> API documentation</a></li></ol></li><li class="chapter-item expanded "><a href="Beginner_Tutorial/beginner_plugin_development_tutorial.html"><strong aria-hidden="true">5.</strong> Beginner Plugin Development Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Beginner_Tutorial/setting_up_plugin_development_environment.html"><strong aria-hidden="true">5.1.</strong> Setting up Plugin Development Environment</a></li><li class="chapter-item expanded "><a href="Beginner_Tutorial/understanding_the_plugin_template.html"><strong aria-hidden="true">5.2.</strong> Understanding the Plugin Template</a></li><li class="chapter-item expanded "><a href="Beginner_Tutorial/creating_objects.html"><strong aria-hidden="true">5.3.</strong> Creating Objects</a></li><li class="chapter-item expanded "><a href="Beginner_Tutorial/adding_object_behaviors.html"><strong aria-hidden="true">5.4.</strong> Adding Object Behaviors</a></li></ol></li><li class="chapter-item expanded "><a href="for_engine_developers.html"><strong aria-hidden="true">6.</strong> For Engine developers</a></li><li class="chapter-item expanded "><a href="common_fixes.html"><strong aria-hidden="true">7.</strong> Common fixes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chatimprovr"><a class="header" href="#chatimprovr">ChatImproVR</a></h1>
<p><img src="images/FZ.png" alt="FZ demo program" /></p>
<h2 id="what-is-chatimprovr"><a class="header" href="#what-is-chatimprovr">What is ChatImproVR?</a></h2>
<p><img src="images/chatimprovr_about.png" alt="visualization_about_chatimprovr" /></p>
<p>ChatImproVR is a virtual world platform, with goals similar to that of VRChat, Neos, or SecondLife. A virtual world platform is a game engine and a set of tools to create and experience an immersive virtual space. These virtual spaces are then hosted online, where users can join them to socialize and enjoy the activities in the virtual world.</p>
<p>ChatImproVR will improve on existing virtual world platforms by promoting open source software and prioritizing user control over content, all while featuring excellent flexibility.</p>
<h2 id="who-is-chatimprovr-for"><a class="header" href="#who-is-chatimprovr-for">Who is ChatImproVR for?</a></h2>
<p>Everyone! But to be more specific, we break down ChatImproVR users into two groups:</p>
<ol>
<li>
<p><strong>Developers</strong>: These are users who work with the backend of the engine. Writing code, implementing plugins, etc. If you are enthusiastic about Rust or developing your own game from scratch, chances are that you're in this developer category.</p>
</li>
<li>
<p><strong>Player</strong>:  Players use the &quot;front end&quot; of the engine. If you are content to put on the VR headset and just play the game without looking at the code too much, you're likely one of the players.</p>
</li>
</ol>
<p>We want everyone to be able to use ChatImproVR for every aspect of the game experience-- from developing the game to playing it!</p>
<h2 id="what-does-chatimprovr-do"><a class="header" href="#what-does-chatimprovr-do">What does ChatImproVR do?</a></h2>
<p>Primarily ChatImproVR is a game engine, but it might be a bit different from the game engines that you are used to, like Unity or Unreal. To break it down, ChatImproVR has a plugin-based architecture. This means that developers can use whatever parts of our engine that they would like, and even add their own features just as easily. The hope is that developers will share the features that they create for the engine, and open-source developers can build the engine <em>together</em>, instead of providing game builders with a front end and limited back end. </p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center">ChatImproVR</th><th style="text-align: center">Professional Game Engine</th><th style="text-align: center">Typical VR Game</th></tr></thead><tbody>
<tr><td>Fully Open Source</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center">❌</td></tr>
<tr><td>Can create games</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center">❌</td></tr>
<tr><td>Visually-focused</td><td style="text-align: center">❌</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td></tr>
<tr><td>Can play games</td><td style="text-align: center">✔️</td><td style="text-align: center">❌</td><td style="text-align: center">✔️</td></tr>
<tr><td>Plugin architecture</td><td style="text-align: center">✔️</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Code-oriented</td><td style="text-align: center">✔️</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Made in Rust</td><td style="text-align: center">✔️</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<p>Here are some examples of games that have been created with ChatImproVR so far:</p>
<p><img src="images/demo_room_rough.JPG" alt="demo_room_rough" />
<em>Demo Room</em></p>
<p><img src="images/cube_example.JPG" alt="cube_example" />
<em>Multiplayer</em></p>
<img src="images/fluid_sim.JPG" width="800">
<p><em>Fluid Simulation</em></p>
<h2 id="how-do-i-get-started"><a class="header" href="#how-do-i-get-started">How do I get started?   <img src="images/ferris_getting_started.svg" width="65"></a></h2>
<p>While this page serves as a product page, it also serves as the documentation page as well. The next section will cover the installation for the <strong>players</strong>. </p>
<p>However, if you are planning to do some plugin development or engine development (being as a <strong>developer</strong>), then we would recommend to check out in the Development Environment section.</p>
<p>If you are interested in the repository, check out <a href="https://github.com/ChatImproVR/chatimprovr">here</a>.</p>
<h2 id="where-can-i-find-help"><a class="header" href="#where-can-i-find-help">Where can I find help?   <img src="images/ferris_confused.svg" width="60"></a></h2>
<p>You're pretty much there! The Book is the information hub of ChatImproVR. Here is where you can find How to make your <a href="https://chatimprovr.github.io/The-Book/Beginner_Tutorial/beginner_plugin_development_tutorial.html">first plugin</a>, common issues and their <a href="https://chatimprovr.github.io/The-Book/common_fixes.html">fixes</a>, or even the <a href="https://chatimprovr.github.io/The-Book/Core_Concepts/core_concepts.html">core concepts</a> of what ChatImproVR is made of.</p>
<p>But just in case The Book doesn't have the help you need, you can also:</p>
<ul>
<li>
<p>Refer to some of our <a href="https://github.com/orgs/ChatImproVR/repositories">example plugins</a></p>
</li>
<li>
<p>Report an <a href="https://github.com/ChatImproVR/chatimprovr/issues">issue</a> in the ChatImproVR engine repository</p>
</li>
<li>
<p>Or, if all else fails, you can contact the devleopers directly:</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Developer Name</th><th>Email</th></tr></thead><tbody>
<tr><td><a href="https://github.com/Masterchef365">Duncan Freeman</a></td><td>duncan.freeman1@gmail.com</td></tr>
<tr><td><a href="https://github.com/Exiled1">Rudy Peralta</a></td><td>rudyperalta831@gmail.com</td></tr>
<tr><td><a href="https://github.com/MrKangs">Kenneth Kang</a></td><td>gykang00@gmail.com</td></tr>
<tr><td><a href="https://github.com/toddgr">Grace Todd</a></td><td>grace.miriam.todd@gmail.com</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This section primarly focuses on installing our ChatImproVR engine.</p>
<h2 id="minimum-requirement"><a class="header" href="#minimum-requirement">Minimum Requirement</a></h2>
<p>As of now, the engine operates on Windows, Mac, and Linux, but it only operates Windows System for VR.</p>
<p>At the same time, the engine has been tested on two seperate VR headsets: Oculus/Meta Quest and SteamVR. </p>
<p>If you are using a different system, please refer to <a href="https://github.com/ChatImproVR/chatimprovr/issues/82">this page</a> for operating system updates. We will update this page as much as possible when additional support is provided. </p>
<p>While we said that it only works on Windows operating system for the two VR headsets, there is still hardware equipment.</p>
<p>When it comes to hardware requirements, your PC must able to support VR software. For example, the Oculus/Meta headset must need to connect the PC. (Trust us... our primary developers tested this on a weak laptop, and it says that it cannot run that application to connect the headset). Please make sure that the headset supported software is able to run and connect the headset. </p>
<h2 id="softwares-to-download"><a class="header" href="#softwares-to-download">Softwares to Download</a></h2>
<p>There are two softwares to download: our engine and the VR connector app. </p>
<h2 id="our-engine"><a class="header" href="#our-engine">Our Engine</a></h2>
<p>If you want to use the stable version, we recommend to <a href="https://github.com/ChatImproVR/chatimprovr/releases">downloading the engine from releases</a>. </p>
<p><a href="https://github.com/ChatImproVR/chatimprovr/releases"><img src="./images/download_buttom.png" alt="Download Button" /></a>. </p>
<p>If you are a <strong>Windows</strong> user, please download the <code>.exe</code>. If you are a <strong>Linux</strong> or <strong>Mac</strong>, please download the file that is stated in the release note (The application that has no extension). From there, you can either run the <code>cimvr_server.exe</code> to host your own server, or the <code>cimvr_client.exe</code> to connect server based on the address of the server.</p>
<p>If you want to use the most up-to-date with some minor bugs, check out the experimental version on the <a href="./development_environment.html">development environment page</a>.</p>
<h2 id="oculus-vr"><a class="header" href="#oculus-vr">Oculus VR</a></h2>
<p>Once you <a href="https://www.oculus.com/Setup/">open the page</a>, you will be greet the follow page as below.</p>
<p><img src="./images/oculus_download_page.png" alt="Oculus Download Page" /></p>
<p>Select the <code>Download Oculus Rift Software</code> button. By selecting the button will open an <code>.exe</code>. Please follow the installation instructions provided on the Oculus website.</p>
<p>Once you have completed the installation of the Oculus Rift Software, connect with your VR headset to the Computer using AirLink or cable connection.</p>
<h2 id="steam-vr"><a class="header" href="#steam-vr">Steam VR</a></h2>
<p>Open the <a href="https://store.steampowered.com/app/250820/SteamVR/">Download Link</a>, and install the Steam VR application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment-version"><a class="header" href="#development-environment-version">Development Environment Version</a></h1>
<p>If you want to develop new plugins or engine features with a version that might have some bugs, but has more features than the stable version, then you can clone our repository from <a href="https://github.com/ChatImproVR/chatimprovr"><strong>HERE</strong></a>. To use this version, there are a few additional steps that need to be completed:</p>
<h2 id="additional-software-download"><a class="header" href="#additional-software-download">Additional Software Download</a></h2>
<p>There are two additional software to download to set up the development environment.</p>
<ol>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a></li>
<li><a href="https://cmake.org/download/">Cmake</a></li>
</ol>
<!-- 1. [Rust (for both Desktop and VR)](#rust)
2. [CMake (For VR only)](#cmake) -->
<!-- ### Rust
When you visit the page for Rust, it will greet you the screen as below.
![Rust Install Page](/images/rust_install_page.png)

Please follow the instructions as they stated. The page might look slighlty different based on operating system.

### CMake
When you visit the [page for Cmake](https://cmake.org/download/), it will greet you the screen as below. Please download the latest version of Cmake that has the option of Windows x64 Installer: the file extension is `.msi`.
![Cmake Install Page](/images/cmake_install_page.png)
In the image above, the version we are downloading is 3.26.4, but you can download and install a higher version if you want as well.

Once you download the installer, open the installer. The first screen should be similar as the following screen.

![Cmake Installer Part 1](/images/cmake_installer_part_1.png)

Select `Next` to continue the installation process.

The next screen will ask regarding the agreement of the program. Select agree to continue the installation process as the image below. You can save the agreement by selecting the `print` option if you want.

![Cmake Installer Part 2](/images/cmake_installer_part_2.png)

In the next screen, we are have an option to install on system path for current user, all users, or not at all. Choose either for the current user or all users to add the system PATH. The image below has selected for all users.

![Cmake Installer Part 3](/images/cmake_installer_part_3.png)

The next screen is selection the program path. The image below has selected the default path, but you can choose whatever path you want.

![Cmake Installer Part 4](/images/cmake_installer_part_4.png)

The next screen is an verifier on selecting all the correct options that you have selected. Once everything is all set, click the `install` button to proceed the installation.

![Cmake Installer Part 5](/images/cmake_installer_part_5.png)

Once the installation is complete, then you will see the following screen.

![Cmake Installer Part 6](/images/cmake_installer_part_6.png) -->
<h2 id="wasm-target"><a class="header" href="#wasm-target">WASM target</a></h2>
<p>Make sure you have the <code>wasm32-unknown-unknown</code> target installed;</p>
<pre><code class="language-sh">rustup target add wasm32-unknown-unknown
</code></pre>
<h2 id="dependencies-on-ubuntu"><a class="header" href="#dependencies-on-ubuntu">Dependencies on Ubuntu:</a></h2>
<pre><code class="language-sh">sudo apt install build-essential cmake libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libspeechd-dev libxkbcommon-dev libssl-dev
</code></pre>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>Build the client, server, and example plugins like so:</p>
<pre><code class="language-sh">pushd server
cargo build --release
popd

pushd client
cargo build --release
cargo build --release --features vr # (For VR/OpenXR support)
popd

pushd example_plugins
./compile_all.sh # (Linux)
# ./compile_all.ps1 # (Windows)
popd
</code></pre>
<p>You can compile all of the example plugins with the <code>compile_all.sh</code> script. 
If you're on windows, you can either use <code>Git Bash</code> to run the <code>.sh</code> files or open a PR; sorry about it!</p>
<p>While most crates <em>are</em> in a workspace, the client crate is unfortunately excluded due to an issue with the <code>openxr</code> crate.</p>
<h2 id="setting-up-the-helper-script"><a class="header" href="#setting-up-the-helper-script">Setting up the helper script</a></h2>
<p>The helper script is intended to make it easy to run the client, server, or both from a single command. The script requires Python 3.</p>
<h3 id="on-linuxunixmacos-bash"><a class="header" href="#on-linuxunixmacos-bash">On Linux/Unix/MacOS (Bash)</a></h3>
<p>If your MacOS system is using <code>bash</code> instead of <code>zsh</code>, then please follow this procedure. Otherwise, please follow the MacOS (Zsh) section.</p>
<p>Assuming you have a copy of <code>chatimprovr</code> somewhere (in this case, <code>$HOME/Projects/chatimprovr</code>), you can put the following in your <code>~/.bashrc</code>:</p>
<pre><code class="language-bash">function cimvr() {
    $HOME/Projects/chatimprovr/cimvr.py $@
}
</code></pre>
<p>This will allow you to access the script as <code>cimvr</code> anywhere.</p>
<blockquote>
<p><em>NOTE: If you do not have the .bashrc file, you need to create on in the $HOME directory.</em></p>
</blockquote>
<h3 id="on-macos-zsh"><a class="header" href="#on-macos-zsh">On MacOS (Zsh)</a></h3>
<p>Assuming you have a copy of <code>chatimprovr</code> somewhere (in this case,  <code>$HOME/Desktop/Rust/chatimprovr</code>), you can put the following in your <code>~/.zshrc</code>:</p>
<pre><code class="language-zsh">function cimvr() {
    $HOME/Desktop/Rust/chatimprovr/cimvr.py $@
}
</code></pre>
<p>This will allow you to access the script as <code>cimvr</code> anywhere.</p>
<blockquote>
<p><em>NOTE: If you do not have the .zshrc file, you need to create on in the $HOME directory.</em></p>
</blockquote>
<h3 id="on-windows"><a class="header" href="#on-windows">On Windows</a></h3>
<p>Assuming you have a copy of <code>chatimprovr</code> somewhere (in this case, <code>C:\Users\dunca\Documents\chatimprovr</code>), you can put the following in your <code>Microsoft.PowerShell_profile.ps1</code>.</p>
<pre><code class="language-ps1">function cimvr() {
    $cimvr_path=&quot;C:\Users\dunca\Documents\chatimprovr&quot;
    python $cimvr_path\cimvr.py $args
}
</code></pre>
<p>This will allow you to access the script as <code>cimvr</code> anywhere.</p>
<blockquote>
<p><em>NOTE: If you cannot find the <code>Microsoft.PowerShell_profile.ps1</code>, you can find the file by typing <code>$profile</code> in Windows PowerShell. There is a chance that <code>Microsoft.PowerShell_profile.ps1</code> might not exist yet. In that case, you need to create a new file and the directory to match that path. In the image below, the file should be located in <code>Documents\WindowsPowerShell</code> under the file name as <code>Microsoft.PowerShell_profile.ps1</code>. If running scripts is disabled on your machine, consult the common fixes section.</em></p>
</blockquote>
<p><img src="./images/profile_path.png" alt="$profile path" /></p>
<h3 id="using-the-script-to-launch-the-engine"><a class="header" href="#using-the-script-to-launch-the-engine">Using the script to launch the engine</a></h3>
<p>After building both <code>chatimprovr</code>'s client and server as well as the example plugins, we could launch the cube example included with ChatImproVR using:</p>
<pre><code class="language-bash">cimvr camera cube
</code></pre>
<p>in the terminal where you installed the helper script.</p>
<h2 id="additional-tips-and-tricks"><a class="header" href="#additional-tips-and-tricks">Additional Tips and Tricks</a></h2>
<h3 id="sparse-registries"><a class="header" href="#sparse-registries">Sparse registries</a></h3>
<p>Recently, the sparse protocol for cargo registries was stablized. This can help improve initial compile times. See <a href="https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html#cargos-sparse-protocol">the rust blog</a>.</p>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>Wasmtime/Cranelift puts a bunch of junk in the log by default. To disable this, put the following in your RC file:</p>
<pre><code class="language-sh">export RUST_LOG=&quot;debug,cranelift=OFF,wasmtime=OFF&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-does-chatimprovr-work"><a class="header" href="#how-does-chatimprovr-work">How does ChatImproVR work?</a></h2>
<p><strong>ChatImproVR is based</strong> on plugins. <strong>Plugins</strong> run on both the <strong>Client</strong> and the <strong>Server</strong>. Each plugin adds functionality to the virtual world by providing a number of <strong>Systems</strong>.</p>
<p>We refer to the <strong>Client</strong> or the <strong>Server</strong> a <strong>Plugin</strong> is running on as the <strong>&quot;Host&quot;</strong>. <strong>Systems</strong> communicate with the <strong>Host</strong> via <strong>Channels</strong> and via the Entity Component System (<strong>ECS</strong>). </p>
<p>The <strong>Host</strong> can communicate with external APIs, and with the <strong>Remote</strong>. From the <strong>Client</strong>'s perspective, the <strong>Remote</strong> is the <strong>Server</strong>. From the <strong>Server</strong>'s perspective, the <strong>Remotes</strong> are the connected <strong>Clients</strong>.</p>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p><strong>Channels</strong> are modeled after the familiar Pub/Sub pattern. <strong>Systems</strong> subscribe to <strong>Channels</strong>, and receive <strong>Messages</strong> via their <strong>Inbox</strong>. Each <strong>Channel</strong> is referred to by it's <strong>Unique ID</strong>. This ID corresponds to exactly one responsibility and associated datatype. <em>If the underlying datatype changes, the ID must also change</em>. This is to ensure compatability between plugins. Otherwise, plugins may consume corrupted data.</p>
<p>Each channel is either <strong>Local</strong> or <strong>Remote</strong>. The <strong>Local</strong> <strong>Channels</strong> can only send <strong>Messages</strong> within their <strong>Host</strong>. Conversely, <strong>Remote Channels</strong> can only send messages to the <strong>Remote</strong>. This is to help avoid confusion as to where a message might have originated, and to make optimizing communication easier.</p>
<h2 id="entity-component-system"><a class="header" href="#entity-component-system">Entity Component System</a></h2>
<p>ChatImproVR's <strong>ECS</strong> is very similar to other game engines' architectures (Bevy being a notable example). Essentially, the <strong>ECS</strong> acts as a global database, where <strong>Entities</strong> are simply keys and <strong>Components</strong> are sparsely populated columns in the metaphorical database. <strong>Systems</strong> make <strong>Queries</strong> to the <strong>ECS</strong>, which are usually joining one more more <strong>Components</strong>. </p>
<p>Each <strong>Host</strong> has it's own <strong>ECS</strong>. The <strong>Server</strong>'s <strong>ECS</strong> is intended to contain the state of the world, while the <strong>Client</strong>'s <strong>ECS</strong>' are intended to contain snapshots of the world and locally visible objects such as graphical user interfaces and markers, as well as predictions of motion or action.</p>
<p>One important difference from other engines is that ChatImproVR handles <strong>Components</strong> via their <strong>Unique ID</strong>, instead of by their datatype. Just like <strong>Channels</strong>, <em>If the underlying datatype changes, the ID must also change</em>. Another important difference is that <strong>Entities</strong> are intended to be <em>universally unique</em>. This means that <strong>Entities</strong> could be transferred between <strong>Servers</strong>, so items in the virtual world can be transferred throughout the metaverse.</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<p>Execution of <strong>Systems</strong> on each <strong>Host</strong> is broken up into a number of <strong>Stages</strong>. Currently, the following stages are available (listed in order of execution):</p>
<ul>
<li><strong>Init</strong>: Executed once, right after the plugin is initialized.</li>
<li><strong>Pre-Update</strong>: Executed before each update, once per <strong>Frame</strong>.</li>
<li><strong>Update</strong>: Executed once per <strong>Frame</strong>.</li>
<li><strong>Post-Update</strong>: Executed after each update, once per <strong>Frame</strong>.</li>
</ul>
<h2 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h2>
<p>There is a special <strong>Sychronized</strong> component which, if attached to an <strong>Entity</strong> on the <strong>Server</strong>, will cause the entire <strong>Entity</strong> and all of it's <strong>Components</strong> to be copied to the <strong>Clients</strong>'s <strong>ECS</strong>. This mechanism is intended to make it very easy to create content which is visible to all <strong>Clients</strong> immediately. </p>
<p>Expect this synchronization to be optimized, so that updates may not be immediate.</p>
<p>In the future, we may offer lazy/immediate/streamed variants of this component.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>One of the most important features behind the engine is the ability to develop a <strong>plugin</strong>. Plugins have the ability to talk to other plugins, and the host. Plugins implement game logic.</p>
<p>Plugins are split into Client and Server sides. This acheived in code like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Declare structures containing state
// Note that the names do not matter, but are informative
// make_app_state!() only cares about the order of it's arguments
struct ServerState;
struct ClientState;

// Expose the these structures to the engine. Order matters!
// This is analogous to main() in a regular Rust program.
make_app_state!(ClientState, ServerState);

// Implement constructors
impl UserState for ClientState {
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        Self
    }
}

impl UserState for ServerState {
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>While both the server and client states are declared in the same plugin, only one will be picked at runtime. The client-side code runs independently on each client, and the server-side code runs in a single instance on the server.</p>
<p>ChatImproVR plugins are written in WebAssembly. See the next section for details!</p>
<h1 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h1>
<p>If you are implementing a plugin which will behave the same on the client and server, 
you may use a type alias to avoid duplicating code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implement your plugin state as usual
struct PluginState;
impl UserState for PluginState {
    // ...
}

// Use a type alias to create an alternate name for the state in order to pass both to make_app_state!() without causing an error
type ServerState = PluginState;
make_app_state!(PluginState, ServerState);

//make_app_state!(PluginState, PluginState); // This would cause an error!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h1>
<h2 id="what-is-webassembly"><a class="header" href="#what-is-webassembly">What is WebAssembly?</a></h2>
<p>WebAssembly (WASM for short) provides a sandboxed environment in which programs written in a variety of languages can interface with a host application. WASM is intended to provide a platform-agnostic and performant alternative to native code.</p>
<h2 id="limitations-and-features"><a class="header" href="#limitations-and-features">Limitations and features</a></h2>
<p>Here we will go over some important aspects of working with WebAssembly in Rust. Firstly, that the standard library is available. Kind of. <strong>In general, functions of the stdlib that communicate with the outside world will not work</strong>; this includes but is not limited to: system time, files, sockets. Instead, one must rely on the interfaces provided by ChatImproVR. One exception to this rule is that allocation <em>does</em> work; one can allocate memory with reckless abandon, at least up to 4 GB.</p>
<h2 id="tips-and-tricks-1"><a class="header" href="#tips-and-tricks-1">Tips and tricks</a></h2>
<h3 id="including-content"><a class="header" href="#including-content">Including content</a></h3>
<p>If you need to include content with your plugin (e.g. models and textures), you may use the <code>include_bytes!()</code> macro provided in the standard library to embed these files in your WASM binary. For more advanced use-cases, consider the <a href="https://docs.rs/include_dir/latest/include_dir/">include dir</a> crate.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>We use the <code>wasm32-unknown-unknown</code> target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system-1"><a class="header" href="#entity-component-system-1">Entity Component System</a></h1>
<p>For general information on the ECS architecture, we recommend looking at <a href="https://en.wikipedia.org/wiki/Entity_component_system">Wikipedia</a>.</p>
<p>This article contains information specific to ChatImproVR's ECS, and some of the specific features it has.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>Entities in ChatImproVR are <strong>universally</strong> unique IDs. As of this writing, this isn't necessarily true in practice, but entities are intended to be treated this way. The point of making universally unique entity IDs is that entities can be transferred client and server, and even between servers without having to worry about collisions. </p>
<p>Entities are created and deleted plugin-side like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_entity = io.create_entity()
    .add_component(Transform::identity())
    .build();
io.remove_entity(my_entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Components in ChatImproVR are identified by their unique ID and by their (maximum) size. This unique ID corresponds to one and <strong>only one</strong> data schema. If the component data type changes, one must also change the ID of the component to avoid corrupting data for potentially reliant third party plugins. One of the less ergonomic aspects of ChatImproVR's current implementation is that components are fixed-size. This means that <strong>a component must serialize to a data length less than or equal to the size prescribed in its ID</strong>. The reason for this is that it makes manipulating components in memory much easier, and necessitates the association of a data type with its (fixed) size.</p>
<p>New components data types are declared like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Component datatype
/// Implements Serialize and Deserialize, making it compatible with the Component trait.
#[derive(Serialize, Deserialize, Clone, Copy, Debug)]
struct MyComponent {
    a: i32,
    b: f32,
}

impl Component for MyComponent {
    // Here we define the universally unique name for this component.
    // Note that this macro simply concatenates the package name with the name you provide.
    // We could have written &quot;channels_example/MyMessage&quot; or even &quot;jdasjdlfkjasdjfk&quot; instead.
    // It's important to make sure your package name is UNIQUE if you use this macro.
    const ID: &amp;'static str = pkg_namespace!(&quot;MyComponent&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>We can take a shortcut!</strong> The <code>Component</code> derive macro does this all automatically!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component, Serialize, Deserialize, Clone, Copy, Debug)]
struct MyComponent {
    a: i32,
    b: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>Components may be added to an entity plugin-side:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.add_component(ent, &amp;MyComponent { a: 0, b: 0.0 });
<span class="boring">}</span></code></pre></pre>
<p>Components on an existing entity may be modified by calling the function above, or by modifying them within a query:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in query.iter() {
    query.write(
        entity,
        &amp;MyComponent {
            a: 1.,
            b: 2312.0,
        },
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="systems"><a class="header" href="#systems">Systems</a></h2>
<p>Systems in ChatImproVR are contained within WebAssembly plugins. Each system corresponds to exactly one ECS query, so that one sets up a System by specifying which components it is associated with. Systems are executed in stages; the <code>Init</code> stage is called when a plugin is initialized, and each frame the <code>PreUpdate</code>, <code>Update</code>, and <code>PostUpdate</code> stages are executed in sequence. </p>
<p>Systems always have the following function signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_system(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {}
<span class="boring">}</span></code></pre></pre>
<p>Systems are in the plugin's constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sched.add_system(Self::update)
    .stage(Stage::Update)
    .query(
            &quot;Query Name&quot;, 
            Query::new()
                .intersect::&lt;MyComponent&gt;(Access::Write)
                .intersect::&lt;MyAnotherComponent&gt;(Access::Read)
    )
    .build();
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://github.com/ChatImproVR/chatimprovr/blob/main/example_plugins/ecs/src/lib.rs">ECS example</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub-channels"><a class="header" href="#pubsub-channels">Pub/Sub channels</a></h1>
<p>ChatImproVR uses the <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish-Subscribe pattern</a>. </p>
<h2 id="receiving-messages"><a class="header" href="#receiving-messages">Receiving messages</a></h2>
<p>Each System subscribes to a number of channels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Schedule the update() system to run every Update,
// and allow it to receive the MyMessage message
sched.add_system(Self::update)
    .stage(Stage::Update)
    .subscribe::&lt;MyMessage&gt;()
    .build();
<span class="boring">}</span></code></pre></pre>
<p>Here we have subscribed to the <code>MyMessage</code>, which will be read every Update when <code>update()</code> is called. </p>
<p>We can read messages from within the system like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult) {
    // Dump the message to the console
    for msg in io.inbox::&lt;MyMessage&gt;() {
        dbg!(msg);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Server-side, we can get some additional information per-message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult) {
    // Dump both the message AND the client that sent the message to the console. 
    // This is only relevant for servers!
    for (client, msg) in io.inbox_clients::&lt;MyMessage&gt;() {
        dbg!((client, msg));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sending-messages"><a class="header" href="#sending-messages">Sending messages</a></h2>
<p>Suppose <code>MyMessage</code> has the following type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
struct MyMessage {
    a: i32,
    b: f32,
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that we derive the <code>Serialize</code> and <code>Deserialize</code> traits.</p>
</blockquote>
<p>We can send the message using the <code>io.send()</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send(&amp;MyMessage {
    a: 9001,
    b: 1337.0,
});
<span class="boring">}</span></code></pre></pre>
<p>Just as we can receive messages with their client IDs on the server, we can also send messages to specific client IDs from the server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send_to_client(&amp;msg, client.id);
<span class="boring">}</span></code></pre></pre>
<p>Here we might have obtained <code>client.id</code> from the <code>Connections</code> [message](TODO: LINK ME TO THE API DOCS!).</p>
<h2 id="defining-message-types"><a class="header" href="#defining-message-types">Defining message types</a></h2>
<p>We need to give our message a universally unique name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Message for MyMessage {
    const CHANNEL: ChannelIdStatic = ChannelIdStatic {
        // Here we define the universally unique name for this message.
        // Note that this macro simply concatenates the package name with the name you provide.
        // We could have written &quot;channels_example/MyMessage&quot; or even &quot;jdasjdlfkjasdjfk&quot; instead.
        // It's important to make sure your package name is UNIQUE if you use this macro.
        id: pkg_namespace!(&quot;MyMessage&quot;),
        // Sent to server
        locality: Locality::Remote,
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Note how we have specified the <code>Locality</code> of this message type. <code>Local</code> messages are sent to other plugins on this host. <code>Remote</code> messages are sent to the remote host. For example, a <code>Remote</code> message sent from a client would be received <em>only</em> at the server.</p>
<p><strong>We can take a shortcut!</strong> The <code>Message</code> derive macro does this all automatically!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Message, Serialize, Deserialize, Debug)]
#[locality(&quot;Remote&quot;)]
struct MyMessage {
    a: i32,
    b: f32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="remote-communication"><a class="header" href="#remote-communication">Remote communication</a></h2>
<p>All Remote messages are sent at the end of each frame.
<img src="Core_Concepts/./remote_communication.svg" alt="Remote messages" /></p>
<p>See the <a href="https://github.com/ChatImproVR/chatimprovr/blob/main/example_plugins/channels/src/lib.rs">channels example</a>.</p>
<h2 id="local-communication"><a class="header" href="#local-communication">Local communication:</a></h2>
<p>Messages are sent between stages, not within stages. Messages may only be received once:
<img src="Core_Concepts/./local_communication.svg" alt="Local communication diagram" /></p>
<p>Messages may be sent and received each stage, even to the stage on the next frame:
<img src="Core_Concepts/./local_communication_2.svg" alt="Local communication diagram 2" /></p>
<p>Messages are broadcasted to all subscribing plugins, including your own plugin:
<img src="Core_Concepts/./local_communication_3.svg" alt="Local communication diagram 3" /></p>
<p>Systems' order of execution is the same as the order in which they were declared:
<img src="Core_Concepts/./local_communication_inside.svg" alt="Local communication diagram (inside)" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-and-server"><a class="header" href="#client-and-server">Client and Server</a></h1>
<p>The client and server play very different roles in plugin developement. Deciding which code belongs server-side and which code belongs client-side can be challenging.</p>
<p>A simple description of the difference in semantics between client and server, is that changes made client-side will only be visible for that client, and changes made server-side can be made visible to <strong>all</strong> connected clients.</p>
<p>For example, let say that a user presses the left key to move an object to the left. If we want that behavior to only be visible for that user, then that code should be part of the client side and we do not need to send a message to the server to change the object. However, if the user wants to move an object which is visible to everyone else in the server, then that movement behavior should happen server-side; The client will send a command to the server requesting that the object must move left.</p>
<p>Therefore, it is worth thinking about the desired behaviors first; If you are planning to develop a plugin that multiple users will interact at the same time, then it is recommended to develop the bahavior of the event on the server-side. If you are planning to develop a story mode game, for example, that only one user will interect with other objects, developing the code client side would make sense and likely result in simpler code.</p>
<h1 id="update-cycles-and-the-synchronized-component"><a class="header" href="#update-cycles-and-the-synchronized-component">Update cycles and the Synchronized component</a></h1>
<p>Many applications in ChatImproVR will have a structure like this:
<img src="Core_Concepts/./flow_diagram.svg" alt="Flow diagram" /></p>
<p>We explain each step in this process below:</p>
<ol>
<li>On initialization, the client-side plugin uploads mesh data to the render engine, in preperation for the cycle. Note that this will not show anything on screen, because there is no entity in the client-side ECS yet.</li>
<li>The client-side plugin receives an input event describing e.g. a key press.</li>
<li>The client-side plugin processes the event, and sends a corresponding message (a movement command) to the server-side plugin.</li>
<li>The server-side plugin processes the movement command and writes to the server-side ECS database. Note that the entity it writes includes a Render Component and a position, which describe which mesh to render and where it should be displayed in the world. Critically, the entity also includes the <code>Synchronized</code> component, which instructs the server to perform the next step:</li>
<li>The ECS data on the server is copied to the client-side ECS. Any existing components attatched the corresponding entity client-side will be overwritten. This process is called <strong>Synchronization</strong>, and it happens automatically for entities which include the <code>Synchronized</code> component.</li>
<li>The render engine queries the client-side ECS database, and displays the entity.</li>
</ol>
<p>The responsibilities of the Plugin are as follows:</p>
<ul>
<li>Client-side
<ul>
<li>Upload mesh data</li>
<li>Receive input events</li>
<li>Publish movement commands corresponding to input events</li>
</ul>
</li>
<li>Server-side
<ul>
<li>Receive movement commands and update the ECS accordingly</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>The following dependency graph illustrates how the crates in ChatImproVR are laid out:
<img src="Core_Concepts/./graph.svg" alt="Visual aid for crate graph" /></p>
<p>Most notably, plugins depend on both <code>cimvr_common</code> and on <code>cimvr_engine_interface</code>. </p>
<p>The crates in ChatImproVR are as follows:</p>
<ul>
<li><code>client</code>: Client application, provides rendering, input, and other user interfacing</li>
<li><code>server</code>: Server application, a headless service</li>
<li><code>engine</code>: WASM Plugin, ECS, and messaging layer for use in implementing server and client</li>
<li><code>engine_interface</code>: Engine interface for use within e.g. plugins</li>
<li><code>common</code>: Interfacing data types between provided plugin, client, and server e.g. position component</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="names"><a class="header" href="#names">Names</a></h1>
<p>In order to communicate between plugins, we need some sort of naming scheme for data types. This naming scheme should be unambigious. We should allow plugins to be designed to use interfaces rather than talk exclusively with just one implementation or provider.</p>
<p>We use strings to identify resources (read: Component and Message datatypes) in ChatImproVR. The convention is to use the pattern <code>MyNamespace/MyResourceName</code>. We provide the <code>pkg_namespace!()</code> macro to automatically prepend your package/crate's name to the given name, allowing you to easily define resource names within the context of your plugin.</p>
<p>Great care should be taken to ensure that the resource name is <strong>Universally Unique</strong>. </p>
<p>One and only one data format can be associated with a resource name. <strong>If the data format of a resource changes, then a new name must be picked</strong>. This is to ensure dependent plugins will not consume garbled data. ChatImproVR does not use a self-describing data format (for efficiency), so collisions can cause data to appear corrupted from the consumer's point of view.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate system</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<p>The rendering interface in ChatImproVR works as follows:</p>
<ol>
<li>Plugins define a <code>MeshHandle</code>, which is just a name for the mesh we will upload. This name will be used in the <code>Render</code> component.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CUBE_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Cube&quot;));
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Plugins send an <code>UploadMesh</code> message containing the <code>MeshHandle</code> and the desired mesh data. This tells the rendering engine about the mesh data, so that we may later reference it by its <code>MeshHandle</code>. </li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send(&amp;UploadMesh {
    mesh: cube(),
    id: CUBE_HANDLE,
});
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>To render a mesh, create an entity with the <code>Transform</code> and <code>Render</code> components. The <code>Transform</code> component specifies the position and orientation of the rendered mesh. This is available in shaders via the <code>mat4 view</code> uniform. The <code>Render</code> component specifies how the mesh is to be displayed; e.g. which primitive to use, indexing limites, etc. Note how we specify which <code>MeshHandle</code> to render!</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.create_entity()
    .add_component(Transform::identity());
    .add_component(Render::new(CUBE_HANDLE))
    .build();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>NOTE: All rendering data is processed client-side; e.g. UploadMesh should be sent in ClientState.</p>
</blockquote>
<p>See the <a href="https://github.com/ChatImproVR/chatimprovr/blob/main/example_plugins/cube/src/lib.rs">cube example</a>!</p>
<h2 id="defining-meshes"><a class="header" href="#defining-meshes">Defining meshes</a></h2>
<p>Meshes are defined using vertices and indices. The default shader uses <code>Vertex</code>'s <code>uvw</code> field to represent vertex color.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API documentation</a></h1>
<p>The two main crates for plugin interfacing are <code>engine_interface</code> and <code>common</code>. </p>
<p>These two have some API documentation written; you can currently access them by running <code>cargo doc --open</code> in either of their directories in <code>chatimprovr</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beginner-plugin-development-tutorial"><a class="header" href="#beginner-plugin-development-tutorial">Beginner Plugin Development Tutorial</a></h1>
<p>In this section, we will go over the basic understanding of plugin development (for beginners). This tutorial will go in depth with strong example codes and explaination of the meaning the syntax. </p>
<p>It's assumed that you have read through the Core Concepts section.</p>
<p>By following this tutorial, you will able to create a knock-off version of <strong>Galaga</strong>. The final version can be found in this <a href="https://github.com/ChatImproVR/galaga">repository</a>. The complete game view we be something similar as the image below.</p>
<p><img src="Beginner_Tutorial/./images/galaga_complete_view.PNG" alt="Complete Galaga View" /></p>
<p>Any beginner with some background of Rust language should be able to follow this tutorial without any issue. If you need some help getting set up with Rust, you can refer to the <a href="https://doc.rust-lang.org/book/">Rust Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-plugin-development-environment"><a class="header" href="#setting-up-plugin-development-environment">Setting up Plugin Development Environment</a></h1>
<p>Plugins are typically developed in their own repositories or folders, separate from the engine repository.</p>
<h2 id="before-plugin-development"><a class="header" href="#before-plugin-development">Before plugin development</a></h2>
<p>Before we start doing any plugin development, you need to set up the engine on your machine. Please refer to the <a href="Beginner_Tutorial/../installation.html">Installation</a> and <a href="Beginner_Tutorial/../development_environment.html">Development Environment</a> to set up the development environment before proceeding.</p>
<h2 id="using-the-template"><a class="header" href="#using-the-template">Using the template</a></h2>
<p>The easiest way to get started with a new plugin is to use the 
<a href="https://github.com/ChatImproVR/template">plugin template repository</a>.</p>
<p><a href="https://github.com/ChatImproVR/template"><img src="Beginner_Tutorial/./images/use_this_template.png" alt="Use this template button" /></a></p>
<p>If you're using another git service besides github, you can clone the repository and remove the default remote:</p>
<pre><code class="language-sh">git clone git@github.com:ChatImproVR/template.git
cd template
git remote remove origin
</code></pre>
<h2 id="modifying-the-helper-script"><a class="header" href="#modifying-the-helper-script">Modifying the helper script</a></h2>
<p>We need to update the plugin path to match the path on your personal machine. For the next section, we will help you out how to modify the helper script based on each terminal.</p>
<blockquote>
<p>Note that all the additional change is inserting line(s) outside of the <code>cimvr</code> function call.</p>
</blockquote>
<h3 id="on-linuxunixmacos-bash-1"><a class="header" href="#on-linuxunixmacos-bash-1">On Linux/Unix/MacOS (Bash)</a></h3>
<p>let's say we want to develop a plugin called <code>foo</code>, that we're developing at <code>$HOME/Projects/foo</code>. Then we could add this to our <code>~/.bashrc</code>:</p>
<pre><code class="language-bash">export CIMVR_PLUGINS=&quot;$HOME/Projects/foo&quot;
</code></pre>
<p>If you are developing on several plugins at the same time, for example <code>foo</code> and <code>poo</code> and <code>foo</code> is located in the <code>$HOME/Projects/foo</code> whereas the <code>poo</code> is located in the <code>$HOME/Desktop/foo</code>, then it will be seperated by the <code>;</code> sign.</p>
<pre><code class="language-bash">export CIMVR_PLUGINS=&quot;$HOME/Projects/foo;$HOME/Desktop/poo&quot;
</code></pre>
<h3 id="on-macos-zsh-1"><a class="header" href="#on-macos-zsh-1">On MacOS (Zsh)</a></h3>
<p>let's say we want to develop a plugin called <code>foo</code>, that we're developing at <code>$HOME/Desktop/Rust/foo</code>. Then we could add this to our <code>~/.bashrc</code></p>
<pre><code class="language-zsh">export CIMVR_PLUGINS=&quot;$HOME/Desktop/Rust/foo&quot;
</code></pre>
<p>If you are developing on several plugins at the same time, for example <code>foo</code> and <code>poo</code> and <code>foo</code> is located in the <code>$HOME/Projects/foo</code> whereas the <code>poo</code> is located in the <code>$HOME/Desktop/foo</code>, then it will be seperated by the <code>;</code> sign.</p>
<pre><code class="language-zsh">export CIMVR_PLUGINS=&quot;$HOME/Desktop/Rust/foo;$HOME/Desktop/poo&quot;
</code></pre>
<h3 id="on-windows-1"><a class="header" href="#on-windows-1">On Windows</a></h3>
<p>Let's say we want to develop a plugin called <code>foo</code>, that we're developing at <code>C:\Users\dunca\Documents\Projects\foo</code>. Then we could add this to our <code>$profile</code>:</p>
<pre><code class="language-ps1">$Env:CIMVR_PLUGINS=&quot;C:\Users\dunca\Documents\Projects\foo&quot;
</code></pre>
<p>If you are developing on several plugins at the same time, for example <code>foo</code> and <code>poo</code> and <code>foo</code> is located in the <code>C:\Users\dunca\Documents\Projects\foo</code> whereas the <code>poo</code> is located in the <code>C:\Users\Mr.Kangs\Desktop\poo</code>, then it will be seperated by the <code>;</code> sign.</p>
<pre><code class="language-ps1">export CIMVR_PLUGINS=&quot;C:\Users\dunca\Documents\Projects\foo;C:\Users\Mr.Kangs\Desktop\galaga&quot;
</code></pre>
<h3 id="using-the-script-to-launch-plugins"><a class="header" href="#using-the-script-to-launch-plugins">Using the script to launch plugins</a></h3>
<pre><code class="language-bash">cimvr foo
</code></pre>
<p>This will start the client and the server with our plugin as arguments. Note that this name <code>foo</code> is determined via package name, the one we set earlier.</p>
<p>The <code>CIMVR_PLUGINS</code> environment variable is a semicolon-seperated list of search paths. We've set it to the path of the plugin under our own plugin, so that it can find <code>foo.wasm</code>.</p>
<blockquote>
<p>Note that the <code>example_plugins</code> directory will be looked for by default, so you don't need to add an environment variable for these.</p>
</blockquote>
<h2 id="tips-and-tricks-2"><a class="header" href="#tips-and-tricks-2">Tips and tricks</a></h2>
<h3 id="using-the-cargo-watch-crate"><a class="header" href="#using-the-cargo-watch-crate">Using the cargo-watch crate</a></h3>
<p>Running e.g. <code>cargo watch -x 'build --release'</code> in your plugin's root will compile it automatically when you save the source. In turn, the engine will reload your plugin automatically. This means you can effectively save source or assets and see the result immediately!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugin-template"><a class="header" href="#plugin-template">Plugin Template</a></h1>
<p>Before we start getting creative with plugin development, lets dive deep into the code to gain a better understanding of what is going on.</p>
<h2 id="plugin-file-structure"><a class="header" href="#plugin-file-structure">Plugin File Structure</a></h2>
<p>The following list is the file structure of the plugin template:</p>
<ul>
<li><code>.cargo</code>
<ul>
<li><code>config.toml</code></li>
</ul>
</li>
<li><code>src</code>
<ul>
<li><code>lib.rs</code></li>
</ul>
</li>
<li><code>.gitignore</code></li>
<li><code>Cargo.toml</code></li>
<li><code>README.md</code></li>
</ul>
<p>New rust developers will be primarily familiar with developing code in <code>main.rs</code>, however plugins are a bit different. Plugins are libraries, so we write code starting from <code>lib.rs</code> instead.</p>
<p>Before we get into the code itself, there is one thing we need to change. This information can be found in the <code>README.md</code> file, but we will go over it here as well.</p>
<h3 id="update-cargotoml-file"><a class="header" href="#update-cargotoml-file">Update Cargo.toml file</a></h3>
<p>Because this code is a template, the code is not fully setup for development. Inside the <code>Cargo.toml</code> file, you will find the following code:</p>
<pre><code class="language-toml">[package]
name = &quot;template_plugin&quot; # CHANGE ME!
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies] # IMPORTANT!
cimvr_common = { git = &quot;https://github.com/ChatImproVR/chatimprovr.git&quot;, branch = &quot;main&quot; }
cimvr_engine_interface  = { git = &quot;https://github.com/ChatImproVR/chatimprovr.git&quot;, branch = &quot;main&quot; } 
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }
</code></pre>
<p>We need to change the name of the plugin. In this tutorial, it will be <strong>galaga</strong>. If we decide not change the name, the plugin will be compiled as <code>template_plugin.wasm</code>. Not only that, but the name will become important later when we use the <code>pkg_namespace!()</code> macro! <strong>Make sure to pick something descriptive, unique, and long.</strong></p>
<p>Note that in the future, ChatImproVR may be available on crates.io or change it's name in git, in which case you will need to update the <code>[dependencies]</code> section!</p>
<p>Therefore, if we are creating the <strong>galaga</strong> plugin, Cargo.toml should look like:</p>
<pre><code class="language-toml">[package]
name = &quot;galaga&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cimvr_common = { git = &quot;https://github.com/ChatImproVR/chatimprovr.git&quot;, branch = &quot;main&quot; }
cimvr_engine_interface  = { git = &quot;https://github.com/ChatImproVR/chatimprovr.git&quot;, branch = &quot;main&quot; }
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }
</code></pre>
<h2 id="understanding-librs"><a class="header" href="#understanding-librs">Understanding lib.rs</a></h2>
<p>Let's switch to the main component, <code>lib.rs</code>. The following code should look similar to <code>lib.rs</code> you have. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cimvr_engine_interface::{make_app_state, prelude::*, println};

// All state associated with client-side behaviour
struct ClientState;

impl UserState for ClientState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        println!(&quot;Hello, client!&quot;);

        // NOTE: We are using the println defined by cimvr_engine_interface here, NOT the standard library!
        cimvr_engine_interface::println!(&quot;This prints&quot;);
        std::println!(&quot;But this doesn't&quot;);

        Self
    }
}

// All state associated with server-side behaviour
struct ServerState;

impl UserState for ServerState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        println!(&quot;Hello, server!&quot;);
        Self
    }
}

// Defines entry points for the engine to hook into.
// Calls new() for the appropriate state.
make_app_state!(ClientState, ServerState);
<span class="boring">}</span></code></pre></pre>
<p>Let's go every line in detail what it means in general.</p>
<h3 id="packages"><a class="header" href="#packages">Packages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cimvr_engine_interface::{make_app_state, prelude::*, println};
<span class="boring">}</span></code></pre></pre>
<p>The <code>cimvr_engine_interface</code> facilitates communication between the plugin and the host. It does not include any interfacing with the specific features of the client or server; instead these datatyes are relegated to the <code>common</code> crate. The third line does not print out since it is part of the standard library that cimvr is not using. In simple terms, the <code>cimvr_engine_interface</code> is the connector between plugins and the engine itself. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>make_app_state!(ClientState, ServerState);
<span class="boring">}</span></code></pre></pre>
<p>The <code>make_app_state!</code> will run and compile the plugin code. In other words, it is the main function of the plugin in order to load into the engine itself.</p>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<p>If you are not familiar with the idea of Client versus Server, please refer to this <a href="Beginner_Tutorial/../Core_Concepts/client_and_server.html">page</a> before continue reading this part of the code. At the same time, the implementation utilize the idea of ECS. If you are not familiar with ECS, please refer to this <a href="Beginner_Tutorial/../Core_Concepts/core_concepts.html#entity-component-system">page</a>.</p>
<p>Before we start implemeting the feature/functionality to the client, we need to declare the client entity. Because there are no required parameter to attached with the client, it will be an empty struct with the name of ClientState. The line below is the method how we will declare it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientState;
<span class="boring">}</span></code></pre></pre>
<p>Now we are going to implement the client side feature/functionality by implementing the idea of UserState. The UserState is define as below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait UserState: Sized {
    /// Constructor for this state; called once before the **Init** stage.
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>All we need to do is to modify the <code>new</code> function with the same parameter. If we want to add more features that correlates to the client side, we can create other functions that are directly implemented to the ClientState entity, but we will walk over when adding behavior to objects and such. At the same time, we will talk more detail regarding the parameter of the new function.</p>
<p>Within the <code>new</code> function, the template contains the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello, client!&quot;); // Line 1
cimvr_engine_interface::println!(&quot;This prints&quot;); // Line 2
std::println!(&quot;But this doesn't&quot;); // Line 3

Self // Line 4
<span class="boring">}</span></code></pre></pre>
<p>The first line will print out in the terminal as how any Rust language will print out: the standard <code>println!</code> statement.
The second line will print out in the terminal but differently. While the first line prints out on the terminal/client side, the second line prints the text on the engine side itself. </p>
<p>The last line is the returning the client UserState as the updated the version for the client.</p>
<p>Which makes up the entire code for the client side itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ClientState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        println!(&quot;Hello, client!&quot;);

        // NOTE: We are using the println defined by cimvr_engine_interface here, NOT the standard library!
        cimvr_engine_interface::println!(&quot;This prints&quot;);
        std::println!(&quot;But this doesn't&quot;);

        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<p>If you are not familiar with the idea of Client versus Server, please refer to this <a href="Beginner_Tutorial/../Core_Concepts/client_and_server.html">page</a> before continue reading this part of the code. At the same time, the implementation utilize the idea of ECS. If you are not familiar with ECS, please refer to this <a href="Beginner_Tutorial/../Core_Concepts/core_concepts.html#entity-component-system">page</a>.</p>
<p>If you have read the client section, the server side present the same idea itself: printing out on the terminal.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All state associated with server-side behaviour
struct ServerState;

impl UserState for ServerState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        println!(&quot;Hello, server!&quot;);
        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In conclusion, the template prints out text in the terminal for both client and server side. In the next section, we will discuss on how to create object in the space and focus on creating both 3D and 2D objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-objects"><a class="header" href="#creating-objects">Creating Objects</a></h1>
<p>Without any objects in the environment, we cannot do anything with it. Now we have our plugin template, let's start working on object creation.</p>
<h2 id="review"><a class="header" href="#review">Review</a></h2>
<p>Before we start adding code to the plugin, review what an ECS is by referring to this <a href="Beginner_Tutorial/../Core_Concepts/entity_component_system.html">page</a>. In short, we need to have a unique ID for each object that is associated with each graphic itself.</p>
<h2 id="adding-packageslibrariescrates"><a class="header" href="#adding-packageslibrariescrates">Adding packages/libraries/crates</a></h2>
<p>Insert the following packages/libraries/crates (we will call them crates for now on) into the very top of <code>lib.rs</code> file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cimvr_engine_interface::{make_app_state, prelude::*, pkg_namespace};

use cimvr_common::{
    glam::{EulerRot, Quat, Vec3},
    render::{Mesh, MeshHandle, Primitive, Render, UploadMesh, Vertex},
    Transform,
};
<span class="boring">}</span></code></pre></pre>
<p>Some of the crates will be familiar from the plugin template such as <code>make_app_state</code> or <code>prelude::*</code>. Here is a brief summary on the remaining crates.</p>
<ul>
<li><code>pkg_namespace</code>: This allows us to easily and uniquely name component and message data types based on our crate's (plugin's) name.</li>
<li><code>cimvr_common</code>: The main crate that handles communcation between server and client.
<ul>
<li><code>render</code>: The main crate for object loading part (the main itself explains that it will render graphics)
<ul>
<li><code>Mesh</code>: This will contain both vertices and indices: <strong>This will be important later on the object creation part</strong>.</li>
<li><code>MeshHandle</code>: This handle refers to a mesh without containing its data</li>
<li><code>Primitive</code>: This will describe the method of rendering the object: <strong>This is important when it comes to object creation</strong>.</li>
<li><code>Render</code>: This component is the most important for rendering; it tells the rendering engine how to render the given <code>MeshHandle</code>.</li>
<li><code>UploadMesh</code>: This will send the mesh to the client.</li>
<li><code>Vertex</code>: It contains the coordinates and rgb value and/or texture coordinates for a given vertex.</li>
</ul>
</li>
<li><code>Transform</code>: The will set the position and orientation of the object.</li>
</ul>
</li>
</ul>
<h2 id="create-id-for-each-object"><a class="header" href="#create-id-for-each-object">Create ID For Each Object</a></h2>
<p>First, we need to declare the <code>MeshHandle</code> to assign each ID for each object. In the game of Galaga, we need to assign four parts: player, enemy, player's bullet, and enemy's bullet.</p>
<p>We can set up the ID values like the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PLAYER_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player&quot;));
const ENEMY_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy&quot;));
const PLAYER_BULLET_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player Bullet&quot;));
const ENEMY_BULLET_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy Bullet&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Each line represents the ID for each entity/object. We will declare a constant value that it is a MeshHandle with the name holder of the object using the <code>pkg_namespace</code>. 
These variables should not be declared in ServerState nor ClientState.</p>
<h2 id="setting-up-the-mesh-for-each-object"><a class="header" href="#setting-up-the-mesh-for-each-object">Setting up the Mesh for Each Object</a></h2>
<p>Now that we have declare the MeshHandle, we need to create the Mesh itself, or the object itself.</p>
<p>If you want to use <code>Blender</code> to create an object and upload that as a mesh into the plugin, please refer the <a href="Beginner_Tutorial//Beginner_Tutorial/creating_objects.html#blender">Blender</a> section of this tutorial.</p>
<p>Let's start making the player object itself. Our design, since it is a basic model, will be a square for the player.
First, we declare a function that returns a Mesh type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player() -&gt; Mesh {}
<span class="boring">}</span></code></pre></pre>
<p>Inside the function, we need to define how big we want to be.
For now, let's define the size variable inside the player function as 5.0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player() -&gt; Mesh {
    let size = 5.0;
}
<span class="boring">}</span></code></pre></pre>
<p>Inside a mesh, there is vertices and indices that we need to define and return.
Let's take a look at the Vertex data type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vertex {
    /// Local position
    pub pos: [f32; 3],
    /// Either u, v, w for textures or r, g, b for colors
    pub uvw: [f32; 3],
}
<span class="boring">}</span></code></pre></pre>
<p>From this point, we will deviate into two sections: 2D and 3D. First we will cover the 2D section. If you want to get information regarding 3D, please refer to <a href="Beginner_Tutorial//Beginner_Tutorial/creating_objects.html#3d">this section</a>, but we highly recommend to read the 2D section first.</p>
<h3 id="2d"><a class="header" href="#2d">2D</a></h3>
<p>As you see above, the Vertex takes [x,y,z] position and [r,g,b] color combination.
The word vertex means a point. We are poviding the point value of the object. Because we decided to make the player as a sqaure rather than fancy object looking, it can define as the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 0
        Vertex::new([size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 1
        Vertex::new([size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 2
        Vertex::new([-size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 3
    ];
<span class="boring">}</span></code></pre></pre>
<p>The variable vertices is vector that contains several vertext of the object itself.
Inside the first Vertex variable, the first array is define as the position of the vertex location whereas the second array is the rgb value. Since we define the value <code>size</code> previously, we can use the value in the x and y value. We are not creating a 3D galaga game, which there is no need to insert a z value. Therefore, the z value is <code>0.0</code> rather than some other numerical value.</p>
<p>For the rgb value, we are using the scale between 0.0 to 1.0 rather than the traditional of 0 to 255. If you want to get the exact value of the rgb value based on the scale between 0 to 255, you can simply do the value desire over 255. For example, if you want to have a certain red value (like 200), the math will be 200/255 which results to 0.7843137255. In this case, we are setting the player object as blue.</p>
<p>Now let's switch our focus to the indices. We need to place the vertex by following the <strong>Right Hand Rule</strong>. For people who do not know what is the Right Hand Rule, it can be explain the image below.</p>
<p><img src="Beginner_Tutorial/./images/right_hand_rule.jpeg" alt="Right Hand Rule In Image" /></p>
<p>Let's say the green arrow represents the x-axis, the blue arrow represents the y-axis, and the red arrow represents the z-axis. If we place the vertex in the counter clockwise order for both x and y values, then the z value will be positive that will be facing us. If we place the order of the vertex in the opposite order/ clockwise, then it will face down. Since we want to place the object facing toward us, we need to place the vertices in the counter clockwise order.</p>
<p>Therefore, the indices variable will be define as below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let indices: Vec&lt;u32&gt; = vec![0,1,2,2,3,0];
<span class="boring">}</span></code></pre></pre>
<p>The 0, 1, 2, 3 came from the Vertex 0, Vertex 1, Vertex 2, and Vertex 3 that is describe above. Vertex 0 is the bottom left corner; Vertex 1 is the bottom right corner; Vertex 2 is upper right corner; and Vertex 3 is the upper left corner of the square.</p>
<p>Here is an example drawing on how it will be displayed.</p>
<p><img src="Beginner_Tutorial/./images/vertex_image_rotation.jpg" alt="Player_Object_Drawing_Method_In_Image" /></p>
<p>Lastly, we need to return the value of Mesh type as the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Mesh {vertices, indices}
<span class="boring">}</span></code></pre></pre>
<p>Therefore the complete version of the player mesh function will be define as following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player() -&gt; Mesh {
    let size: f32 = 5.0;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 0
        Vertex::new([size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 1
        Vertex::new([size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 2
        Vertex::new([-size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 3
    ];

    let indices: Vec&lt;u32&gt; = vec![0,1,2,2,3,0];

    Mesh {vertices, indices}
}
<span class="boring">}</span></code></pre></pre>
<p>For each object, we need to the followng for the remaining enemy. enemy's bullet, and player's bullet. If you want to learn more depth regarding drawing objects, here is a <a href="https://learnopengl.com/Getting-started/Hello-Triangle">great resource</a> to refer.</p>
<h3 id="3d"><a class="header" href="#3d">3D</a></h3>
<p>With the same approach as creating 2D objects, we need to increase more vertex and identify which indices will connect to which indices. The following code will make a cube instead of a sqaure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Defines the mesh data fro a cube
fn cube() -&gt; Mesh {
    // Size of the cube mesh
    let size = 0.25;

    // List of vertex positions and colors
    let vertices = vec![
        Vertex::new([-size, -size, -size], [0.0, 1.0, 1.0]),
        Vertex::new([size, -size, -size], [1.0, 0.0, 1.0]),
        Vertex::new([size, size, -size], [1.0, 1.0, 0.0]),
        Vertex::new([-size, size, -size], [0.0, 1.0, 1.0]),
        Vertex::new([-size, -size, size], [1.0, 0.0, 1.0]),
        Vertex::new([size, -size, size], [1.0, 1.0, 0.0]),
        Vertex::new([size, size, size], [0.0, 1.0, 1.0]),
        Vertex::new([-size, size, size], [1.0, 0.0, 1.0]),
    ];

    // Each 3 indices (indexing into vertices) define a triangle
    let indices = vec![
        3, 1, 0, 2, 1, 3, 2, 5, 1, 6, 5, 2, 6, 4, 5, 7, 4, 6, 7, 0, 4, 3, 0, 7, 7, 2, 3, 6, 2, 7,
        0, 5, 4, 1, 5, 0,
    ];

    Mesh { vertices, indices }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sending-the-mesh-from-client-to-server"><a class="header" href="#sending-the-mesh-from-client-to-server">Sending the Mesh from Client to Server</a></h2>
<p>Once we have generated the Mesh for each object with the correct Render ID, we need to send that Mesh with the correct ID to the server. Inside the new function below, we need to insert the following command.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send(&amp;UploadMesh{
    id: PLAYER_HANDLE,
    mesh: player(),
});

<span class="boring">}</span></code></pre></pre>
<p>Let's take a deep look into this command itself.</p>
<p>The command will send to the EngineIo as a <code>UploadMesh</code> struct that contains the Render ID and the mesh itself. We know both of the id (<code>PLAYER_HANDLE</code>) and the mesh (<code>player()</code>). </p>
<p>That is all for sending mesh from the client to the server. Pretty easy. The complete code will be looking similar below. This implementation is inside the <code>ClientState</code> <code>new</code> function. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        io.send(&amp;UploadMesh{
            id: PLAYER_HANDLE,
            mesh: player(),
        });

        Self
}
<span class="boring">}</span></code></pre></pre>
<p>You do the same process for all the remaining objects such as the enemy, enemy_bullets, and the player_bullets.</p>
<h2 id="blender"><a class="header" href="#blender">Blender</a></h2>
<p>While using Mesh is great by declearing a type and modify from there, it is very limited to the extend of creating more unique objects. Therefore, we have a different method to implement mesh into the plugin using <code>Blender</code>!</p>
<p>The object loader is already part of CimVR that we just need to update the <code>Cargo.toml</code> file. Inside the <code>Cargo.toml</code> file of your plugin, add a new line under dependencies.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>obj_reader = {path = &quot;../chatimprovr/obj_loader&quot;} // The path might look different 
<span class="boring">}</span></code></pre></pre>
<p>You can declare whatever you want, but make sure the path is located in the right file that will read the file. </p>
<p>Once that is complete, you need to use that crate to load the function <code>obj_lines_to_mesh</code>.</p>
<p>At the beginning of the <code>lib.rs</code> file where you declare crates, add the following line.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add libraries from the obj_reader crate
use obj_reader::obj::obj_lines_to_mesh;
// If you name the dependency differently, then change the name accordingly
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-between-blender-and-chatimprovr"><a class="header" href="#differences-between-blender-and-chatimprovr">Differences between Blender and ChatImproVR</a></h2>
<p>The biggest differences between Blender and ChatImproVR is axes are different. Take a look at the following image below.</p>
<p><img src="Beginner_Tutorial/./images/xyz_reference.png" alt="XYZ_Reference" /></p>
<p>The color lines represent axes in ChatImproVR whereas the solid white lines with the labels for each axes represent the axes in Blender.
For people who are not familiar with the color line axes representation, here is a summary about it.</p>
<ul>
<li>Red Line represents the <strong>X-axis</strong></li>
<li>Green Line represents the <strong>Y-axis</strong></li>
<li>Blue Line represents the <strong>Z-axis</strong></li>
<li>The Solid Lines represent <strong>positive</strong> direction</li>
<li>The Dotted Lines represent <strong>negative</strong> direction</li>
</ul>
<p>As you see, the blender axes does not match with the ChatImproVR axes; for example, the Y-axis for blender is on the Z-axis for ChatImproVR. Therefore, we need to make sure to export the object correctly so that we do not need to modify the object viewing inside the code (In this tutorial, we had to modify to show other features; hence, we highly recommed to follow this section.)</p>
<p>For the biggest difference is that the <strong>negative Y-axis</strong> in <strong>Blender</strong> is <strong>positive Z-axis</strong> in <strong>ChatImproVR</strong> whereas <strong>positive Z-axis</strong> in <strong>Blender</strong> is <strong>positive Y-axis</strong> in <strong>ChatImproVR</strong>.</p>
<h2 id="how-to-create-an-object-in-blender-and-export-correctly"><a class="header" href="#how-to-create-an-object-in-blender-and-export-correctly">How to Create an Object in Blender and Export Correctly</a></h2>
<p>Now we know what is the major differences, how do we export the object correctly using blender? First, we need to create an object in Blender. There are many tutorials on how to make an object of whatever design you prefer. Once the object has been created in Blender, follow the next steps.</p>
<ol>
<li>In <strong>File</strong>, select <strong>Export</strong>, then select <strong>Wavefront</strong> like the image below. It should have the file type as <strong>(.obj)</strong></li>
</ol>
<p><img src="Beginner_Tutorial/./images/Blender_Export_Step_1.png" alt="Step 1" /></p>
<ol start="2">
<li>
<p>Match the option as the image below.
<img src="Beginner_Tutorial/./images/blender_export_option.png" alt="Step 2" /></p>
</li>
<li>
<p>Once that settings is correct, then select export to your desired location with the desired object file name. In our case, we are going to save it in <code>src/assets</code>.</p>
</li>
</ol>
<h2 id="how-to-send-an-object-from-blender-from-client-to-server"><a class="header" href="#how-to-send-an-object-from-blender-from-client-to-server">How to send an Object from Blender from Client to Server</a></h2>
<p>The process of sending a object mesh from Blender from client to server is very similar like how you send a mesh that is created inside the plugin. Inside the <code>new</code> function, insert the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send(&amp;UploadMesh {
            id: ENEMY_HANDLE,
            mesh: obj_lines_to_mesh(include_str!(&quot;assets/circle.obj&quot;)),
        });
<span class="boring">}</span></code></pre></pre>
<p>The only difference between the previous method and this method is the <code>mesh</code> component: instead of custom created mesh, we are using the <code>obj_lines_to_mesh</code> function to load the mesh. In the example above, by inserting the <code>obj_lines_to_mesh</code> function with the argument of the path of object file (in this case will be the <code>circle.obj</code> file), it will load properlly.</p>
<p>Once that is complete, then we have sent the Render ID and mesh to the server. For this plugin, we will using the player and enemies as of now. We will add more objects mesh as we continue the tutorial.</p>
<h2 id="how-to-display-the-object-from-the-server"><a class="header" href="#how-to-display-the-object-from-the-server">How to display the Object from the Server</a></h2>
<p>Based on the client side code, we are just sending the Render ID to the server, not the mesh data itself. Therefore, in order to render the entity we want to display, we need to call the Render ID while we are creating the entity.</p>
<h2 id="so-how-do-you-create-an-entity"><a class="header" href="#so-how-do-you-create-an-entity">So, how do you create an entity?</a></h2>
<p>In the <code>ServerState</code> implementation, we will add the following commands inside the <code>new</code> function for creating the player entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Player entity with components
        io.create_entity()
            // Add the render component to draw the player with lines
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Add the transform component for movement
            .add_component(Transform::default())
            // Build the entity
            .build();
<span class="boring">}</span></code></pre></pre>
<p>We can split into (technically two) three functions when creating the entity using <code>io</code>. The first line <code>.create_entity()</code> tells the server that we are creating an entity. The second to fourth line that contains the function <code>.add_component</code> is the method of adding component as name states. In layman terms, we are adding characteristics to the entity. The last line that contains the <code>.build();</code> tells the server that we are done adding component to this entity and build it.</p>
<p>The most important function when creating is <code>.add_component()</code> function call. In the code/example above, there are three unique calls, which will cover each part in depth.</p>
<h3 id="render"><a class="header" href="#render">Render</a></h3>
<p>When you add this component to a certain entity, it indicates that we are giving an render data to this entity that could appear on the client side. This is where we use the Render ID to render the entity that was sent from the client side. In the given example, we are going to render this entity as a player by providing the <code>PLAYER_HANDLE</code> Render ID to the entity. This explains up to the part of <code>.add_component(Render::new(PLAYER_HANDLE))</code>.</p>
<p>The <code>.primitive(Primitive::Lines)</code> part explains what method are we going to render. There are three methods to render the entity: <code>Lines</code>, <code>Points</code>, or <code>Triangles</code>. The name itself explains how it will be render except <code>Triangles</code>. The <code>Triangles</code> method use the idea of the right hand rule that by providing the three vertices to format as a triangle will fill out the area with the given color. In this case, because the player ship is created over blender with only lines, the example says Lines, but if you want to render in a different method, you are welcome to do so.</p>
<h3 id="synchronized"><a class="header" href="#synchronized">Synchronized</a></h3>
<p>When you add this component to a certain entity, it indicates that whatever happens to the server will also update on the client side as well. We want to have this component; for example, if the player is hit from the enemy's bullet, then the player must be deleted, but if we do not have this component, the client will never know when it should be deleted or not.</p>
<p>If the client do not care regarding updates from the server side, then you do not need to add this component. Otherwise, must add this component.</p>
<h3 id="transform"><a class="header" href="#transform">Transform</a></h3>
<p>When you add this component to a certain entity, it indicates that this entity will be display on the client side whether or not it has a mesh data. This component seems somewhat redundent and useless at first because the entity will be display even without any render data; in other words, why would call this component if you do not need to render something. However, the transform allows you to do a lot of customization when it comes to positioning and rotation, which will cover in the next section.</p>
<h2 id="customizing-the-render-settings"><a class="header" href="#customizing-the-render-settings">Customizing the render settings</a></h2>
<p>Take a good look at the following example code below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Player entity with components
        io.create_entity()
            // Add the transform component for movement
            .add_component(
                // Add the default transform component
                Transform::default()
                    // Set the bottom middle of the screen as the initial position
                    .with_position(Vec3::new(0.0, -50.0, 0.0))
                    // Set the initial rotation to be facing towards to the player based on the camera angle (no needed if you create the object facing a different direction)
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, PI/2., 0., 0.)),
            )
            // Add the render component to draw the player with lines
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();
<span class="boring">}</span></code></pre></pre>
<p>There are two things you have noticed:</p>
<ol>
<li>The order of adding the component is different than the previous example. This tells that adding the component order does not matter what so ever. </li>
<li>There are more functions from the <code>Transform</code> component.</li>
</ol>
<p>Within each call for adding new components, you can set even more options in depth of the entity. In this example, we want to set the component location below the screen, where the player should be located. Therefore, we add te <code>.with_position()</code> function call with a <code>Vec3</code> input value of the position. Since it should be display in the bottom middle screen, the position will be <code>Vec3(0.,-50.,0.)</code>.</p>
<p>Because the object is created by Blender with the <code>xyz</code> reference is relative rather than objective, there is a need to rotate the object based on the X-axis by 90 degrees in radines (which it is PI/2). Therefore, we also need to call <code>.with_roation()</code> with the value of <code>Quat::from_euler(EulorRot::XYZ,PI/2.,0.,0.)</code>. At the same time, we need to add the PI value from the standard libary. Therefore, add the <code>use std::{f32::consts::PI};</code> in the beginning of the file.</p>
<p>We will create entities for enemy as well: NOT THE BULLET.</p>
<h2 id="wait-what-about-the-bullets"><a class="header" href="#wait-what-about-the-bullets">Wait...? What about the bullets?</a></h2>
<p>In the new function inside the ServerState, we have generated the entities for Player and Enemy, but not the bullets. Why?</p>
<p>The new function will generate the entity when the program starts. In other words, when the program starts, the entity (if we add the componenet to display) will display at the beginning, which it is not the case for bullets. We want to create and remove the bullets when the player press a certain button to shoot the bullet or the enemy decides to shoot the bullet. </p>
<p>Therefore, we are going to generate the bullet based on certain function input. We will go in depth about it, but we can simply ignore the bullet at this point.</p>
<h2 id="configuring-the-camera-angle"><a class="header" href="#configuring-the-camera-angle">Configuring the Camera Angle</a></h2>
<p>Inside the engine's example plugins, there are several plugins that you can refer to. One of the example plugin that we are using is <code>camera2d</code> plugin. This plugin will automatically set the camera angle as a 2D angle. Therefore, if you want to see the current progress, all you need to do (after compiling the galaga code) is entering the following.</p>
<p><code>cimvr galaga camera2d</code> or <code>cimvr camera2d galaga</code>. The order does not matter when it comes to calling the plugin.</p>
<p>If you want to customize the camera in your own angle, please refer the documentation in the camera utility.</p>
<h2 id="summarycurrent-code-progress"><a class="header" href="#summarycurrent-code-progress">Summary/Current Code Progress</a></h2>
<p>The following code should be similar to the code that is provided.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{f32::consts::PI};

// Add libraries from the cimvr_engine_interface crate
use cimvr_engine_interface::{make_app_state, pkg_namespace, prelude::*};

// Add libraries from the cimvr_common crate
use cimvr_common::{
    glam::{EulerRot, Quat, Vec3},
    render::{Mesh, MeshHandle, Primitive, Render, UploadMesh, Vertex},
    Transform,
};

// Add libraries from the obj_reader crate
use obj_reader::obj::obj_lines_to_mesh;

// Create some constant value for Windows
const WITDH: f32 = 80.;
const HEIGHT: f32 = 120.;

// Create some constant values for Enemy
const ENEMY_SIZE: f32 = 3.; 

// Create some constant values for Player
const PLAYER_SIZE: f32 = 3.; // Because of the obj file, this value is not used (update this value after changing the obj size)

// Create some constant values for Bullet
const BULLET_SIZE: f32 = 0.5;


// Create mesh handleer based on each object's name
const PLAYER_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player&quot;));
const ENEMY_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy&quot;));
const PLAYER_BULLET_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player Bullet&quot;));
const ENEMY_BULLET_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy Bullet&quot;));
const WINDOW_SIZE_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Window Size&quot;));

// Create Meshes for each object

// Create the Player Mesh --&gt; This is commented out because we are using obj file
// fn player() -&gt; Mesh {
//     let size: f32 = PLAYER_SIZE;

//     let vertices = vec![
//         Vertex::new([-size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 0
//         Vertex::new([size, -size, 0.0], [0.0, 0.0, 1.0]),  // Vertex 1
//         Vertex::new([size, size, 0.0], [0.0, 0.0, 1.0]),   // Vertex 2
//         Vertex::new([-size, size, 0.0], [0.0, 0.0, 1.0]),  // Vertex 3
//     ];

//     let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

//     Mesh { vertices, indices }
// }

// // Create the Enemy Mesh --&gt; This is commented out because we are using obj file
// fn enemy() -&gt; Mesh {
//     let size: f32 = ENEMY_SIZE;

//     let vertices = vec![
//         Vertex::new([-size, -size, 0.0], [1.0, 0.0, 0.0]), // Vertex 0
//         Vertex::new([size, -size, 0.0], [1.0, 0.0, 0.0]),  // Vertex 1
//         Vertex::new([size, size, 0.0], [1.0, 0.0, 0.0]),   // Vertex 2
//         Vertex::new([-size, size, 0.0], [1.0, 0.0, 0.0]),  // Vertex 3
//     ];

//     let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

//     Mesh { vertices, indices }
// }

// Create Player Bullet Mesh as a sqaure green
fn player_bullet() -&gt; Mesh {
    let size: f32 = BULLET_SIZE;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([size, -size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([size, size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([-size, size, 0.0], [0.0, 1.0, 0.0]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

    Mesh { vertices, indices }
}

// Create Enemy Bullet Mesh as a sqaure red
fn enemy_bullet() -&gt; Mesh {
    let size: f32 = BULLET_SIZE;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([size, -size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([size, size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([-size, size, 0.0], [1.0, 0.0, 0.0]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

    Mesh { vertices, indices }
}

// Create Window Mesh so that the users will know what is the limit of movement
fn window_size() -&gt; Mesh {
    let vertices = vec![
        Vertex::new([-WITDH / 2., -HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([WITDH / 2., -HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([WITDH / 2., HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([-WITDH / 2., HEIGHT / 2., 0.0], [1.; 3]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 0, 1, 1, 2, 2, 3];

    Mesh { vertices, indices }
}

#[derive(Default)]
struct ClientState;

impl UserState for ClientState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Declare the player color as green
        let player_color = [0., 1., 0.];

        // Read the player object file from the assets folder (that is created from blender)
        let mut new_player_mesh = obj_lines_to_mesh(&amp;include_str!(&quot;assets/galagaship.obj&quot;));

        // Update the player object/mesh with the player color
        new_player_mesh
            .vertices
            .iter_mut()
            .for_each(|v| v.uvw = player_color);

        // Declare the enemy color as red
        let enemy_color = [1., 0., 0.];

        // Read the enemy object file from the assets folder (that is created from blender)
        let mut new_enemy_mesh = obj_lines_to_mesh(&amp;include_str!(&quot;assets/galaga_enemy.obj&quot;));

        // Update the enemy object/mesh with the enemy color
        new_enemy_mesh
            .vertices
            .iter_mut()
            .for_each(|v| v.uvw = enemy_color);

        // Send the player mesh and the player mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: PLAYER_HANDLE,
            mesh: new_player_mesh,
        });

        // Send the enemy mesh and the enemy mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: ENEMY_HANDLE,
            mesh: new_enemy_mesh,
        });

        // Send the player bullet mesh and the player bullet mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: PLAYER_BULLET_HANDLE,
            mesh: player_bullet(),
        });

        // Send the enemy bullet mesh and the enemy bullet mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: ENEMY_BULLET_HANDLE,
            mesh: enemy_bullet(),
        });

        // Send the window mesh and the window mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: WINDOW_SIZE_HANDLE,
            mesh: window_size(),
        });

        Self::default()
    }
}

// All state associated with server-side behaviour
struct ServerState;

// Implement server only side functions that will update on the server side
impl UserState for ServerState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {

        // Create Player entity with components
        io.create_entity()
            // Add the transform component for movement
            .add_component(
                // Add the default transform component
                Transform::default()
                    // Set the bottom middle of the screen as the initial position
                    .with_position(Vec3::new(0.0, -50.0, 0.0))
                    // Set the initial rotation to be facing towards to the player based on the camera angle (no needed if you create the object facing a different direction)
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, PI/2., 0., 0.)),
            )
            // Add the render component to draw the player with lines
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();

        // Create Enemy with components
        io.create_entity()
            // Add the transform component for movement, firing, and displaying
            .add_component(
                // Add the default transform component
                Transform::default()
                    // Set the top middle of the screen as the initial position
                    .with_position(Vec3::new(0.0, 50.0, 0.0))
                    // Set the initial rotation to be facing towards to the player based on the camera angle
                    // (no needed if you create the object facing a different direction or differen angle rotation)
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, 90., 0., 0.)),
            )
            // Add the render component to draw the enemy with lines
            .add_component(Render::new(ENEMY_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();

        // Create the Window entity with components
        io.create_entity()
            // Add the transform component for displaying the window
            .add_component(Transform::default())
            // Add the render component to draw the window with lines
            .add_component(Render::new(WINDOW_SIZE_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();
    Self
    }
}

// Defines entry points for the engine to hook into.
// Calls new() for the appropriate state.
make_app_state!(ClientState, ServerState);
<span class="boring">}</span></code></pre></pre>
<p>By having this code, you should get something similar like the following.</p>
<p><img src="Beginner_Tutorial/./images/Complete_view_of_object_creation.png" alt="Complete Object Creation Galaga View" /></p>
<p>The bottom object in the screen is the player whereas the red object that is near the top of the screen is the enemy. It does not have to be the same shape, but if each object is define as player and enemy, then we are good shape.</p>
<p>If you are not getting similar view, then please let us know so that we can help you out. Otherwise, we are ready to move to the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-object-behaviors"><a class="header" href="#adding-object-behaviors">Adding Object Behaviors</a></h1>
<p>Up to now, we have worked around the fundamentals of the plugin and creation of objects/entities. This section is the highlight of the plugin, where things get interesting.</p>
<p>There are behavior variables we need to add for each object:</p>
<ul>
<li>User Input Movement Control for Player</li>
<li>Random Input Movement Control for Enemy</li>
<li>User Input Fire Control for Player</li>
<li>Random Input Fire Control for Enemy</li>
<li>Bullet Interaction between each entity (spawning, collision)</li>
</ul>
<h2 id="before-we-start"><a class="header" href="#before-we-start">Before We Start...</a></h2>
<p>Let's review the current code we have at the moment. We have a &quot;player,&quot; an &quot;enemy,&quot; and a window screen. Although the window screen may not be as relevant, we need to determine how we can distinguish between the player and the enemy. Based on the code, we can visually identify their differences (which computers cannot), but what other distinctions are there? Apart from their positions, there isn't much else. Consequently, we need to incorporate additional components (characteristics) to make each entity unique. Before we begin implementing these behaviors, let's assign specific characteristics to each entity.</p>
<h2 id="creating-additional-component-creating-characteristics"><a class="header" href="#creating-additional-component-creating-characteristics">Creating additional Component (Creating Characteristics)</a></h2>
<p>Up until this point, there is a strong likelihood that our code structures are mostly similar. However, going forward, the code may start to diverge significantly as we incorporate different characteristics for each entity. Therefore, if you disagree with the logic of this tutorial, feel free to modify it according to your own understanding. In other words, from this point on, we recommend focusing on grasping the concepts and syntax of the game engine rather than simply copying and pasting the entire code and considering it complete. With that being said...</p>
<h3 id="player-component"><a class="header" href="#player-component">Player Component</a></h3>
<p>First, we will work on the &quot;Player&quot; component. We need to have the current player position so that the server can change based on the user input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add Player Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Player {
    pub current_position: Vec3,
}

// Implement Default for Player Component
impl Default for Player {
    fn default() -&gt; Self {
        Self {
            current_position: Vec3::new(0.0, -50.0, 0.0),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The struct declares the component of the Player, whereas the implementation of the Player will initilize the default component. We know we want the player to be at -50 at the Y position when the player spawns (as a default).</p>
<h3 id="enemy-component"><a class="header" href="#enemy-component">Enemy Component</a></h3>
<p>Unlike the Player component, we want to add another character than just current position of the enemy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add Enemy Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Enemy {
    pub current_position: Vec3,
    pub bullet_count: u32,
}

// Implement Default for Enemy Component
impl Default for Enemy {
    fn default() -&gt; Self {
        Self {
            current_position: Vec3::new(0.0, 50.0, 0.0),
            bullet_count: 0,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In addition to the default position of the enemy, the struct will now include a bullet count. The bullet count represents the number of bullets that the enemy has on the screen. Therefore, when the scene is first loaded, the default value for the enemy's position will be 50 units in the Y-axis, while the bullet count will be set to 0.</p>
<p>You might wonder why the Player component does not have a bullet limit. While you can certainly add a bullet count limit to the Player component, we have not included one in this tutorial. The reason for this is that the main objective is to differentiate between each entity by having different components. In other words, if we were to use the same struct for both the enemy and the player, the components themselves would serve as the distinguishing factor between the entities.</p>
<h3 id="bullet-component"><a class="header" href="#bullet-component">Bullet Component</a></h3>
<p>Here are a few snippets of code for adding a bullet component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add Bullet Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Bullet {
    from_player: bool,
    from_enemy: bool,
    entity_id: EntityId,
}

// Implement Default for Bullet Component
impl Default for Bullet {
    fn default() -&gt; Self {
        Self {
            from_player: false,
            from_enemy: false,
            entity_id: EntityId(0),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>entity_id</code> represents the parent of the entity. For example, the player entity's id or enemy entity's id will be in the <code>entity_id</code> to identify which entity of the player/enemy it came from. We will have more than one enemy, so we need to keep track which enemy entity is it from.</p>
<h3 id="playerstatus-component"><a class="header" href="#playerstatus-component">PlayerStatus Component</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add Player Status Component; this is used as a spwan timer for Player
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct PlayerStatus {
    pub status: bool,
    pub dead_time: f32,
}

// Implement Default for Player Status Component
impl Default for PlayerStatus {
    fn default() -&gt; Self {
        Self {
            status: true,
            dead_time: 0.0,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This component is for tracking the spawn time for the player and checking the status of the player whether it is dead or not.</p>
<h3 id="enemystatus-component"><a class="header" href="#enemystatus-component">EnemyStatus Component</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add Enemy Status Component; this is used as a spwan timer for Enemy
#[derive(Component, Serialize, Deserialize, Copy, Clone, Default)]
pub struct EnemyStatus(f32);
<span class="boring">}</span></code></pre></pre>
<p>As the comment says, this component will track the spawn timer for the enemy.</p>
<!-- 
### Score Component
```rust
// Add Score Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Score {
    pub score: u32,
    pub second_digit: u32,
    pub first_digit: u32,
    pub second_digit_entity: EntityId,
    pub first_digit_entity: EntityId,
}

impl Default for Score {
    fn default() -> Self {
        Self {
            score: 0,
            second_digit: 10,
            first_digit: 10,
            second_digit_entity: EntityId(0),
            first_digit_entity: EntityId(0),
        }
    }
}
```
I don't want to add this at this point since this implementation will change soon. -->
<h2 id="adding-the-component-characteristics-to-the-right-entity"><a class="header" href="#adding-the-component-characteristics-to-the-right-entity">Adding the component (characteristics) to the right entity</a></h2>
<p>Let's take a look at the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All state associated with server-side behaviour
struct ServerState;

// Implement server only side functions that will update on the server side
impl UserState for ServerState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Create a player status entity (not player entity)
        io.create_entity()
            .add_component(PlayerStatus::default())
            .build();

        // Create an enemy status entity (not enemy entity)
        io.create_entity().add_component(EnemyStatus(0.0)).build();

        // Create Player entity with components
        io.create_entity()
            .add_component(
                Transform::default()
                    .with_position(Vec3::new(0.0, -50.0, 0.0))
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, 90., 0., 0.)),
            )
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            .add_component(Player::default())
            .add_component(Synchronized)
            .build();

        // Create Enemy with components
        io.create_entity()
            .add_component(
                Transform::default()
                    .with_position(Vec3::new(0.0, 50.0, 0.0))
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, 90., 0., 0.)),
            )
            .add_component(Render::new(ENEMY_HANDLE).primitive(Primitive::Lines))
            .add_component(Synchronized)
            .add_component(Enemy::default())
            .build();

        // Create the Window entity with components
        io.create_entity()
            .add_component(Transform::default())
            .add_component(Render::new(WINDOW_SIZE_HANDLE).primitive(Primitive::Lines))
            .add_component(Synchronized)
            .build();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you might have noticed, it is implemented in the same way as <code>Render</code>, <code>Transform</code>, and <code>Synchronized</code>. The only difference is that if we declare a default setting for the component, we can call default, otherwise, we need to fill out the struct when it is initialized. For example, the <code>EnemyStatus</code> does not have a default implementation; therefore, we need to add a <code>f32</code> value into that component. Since <code>EnemyStatus</code> is a timer of the spawn time, it should be initialized as <code>0.0</code>. You can implement a default value as well, even though we don't implement it here.</p>
<!-- There is one component that you have not seen above; it is a `Score` component. This updated version will be out soon; in fact, we will talk about that in the next page of this tutorial. -->
<h2 id="communication-from-client-to-server"><a class="header" href="#communication-from-client-to-server">Communication from Client to Server</a></h2>
<p>The most common method that we will be using is communication from client to server. If you want to know more about how this works, <a href="Beginner_Tutorial//Core_Concepts/client_and_server.html">check out our core concepts docs.</a>. The method we will be using is called <a href="Beginner_Tutorial//Core_Concepts/pub_sub.html">subscribe/publish method</a>. In short, the client will send a message to the server, and the server will update based on that message call. This method involves serializing and deserializing the message: the client will serialize the message before it sends to the server, and the server will deserialize the message to read the message. Therefore, we will need to use the following library.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialze};
<span class="boring">}</span></code></pre></pre>
<p>Insert the following line where the other libraries are located.</p>
<h3 id="creating-a-movement-input-message-container"><a class="header" href="#creating-a-movement-input-message-container">Creating a Movement Input Message Container</a></h3>
<p>Before we start writing out the message container, we need to structure what message we want to send to the server from the client. We want to have the information on what direction/vector the object needs to move. The message can also contain information on which object will be moving, but for a game of Galaga, we know the only object that a user would be able to move is the player object, so we don't need to specify that here (However, if we wanted to expand Player versus Player gameplay, then we do want to mention it). The following code will be the message container that we will be using for this tutorial.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add movement command as message from client to server
#[derive(Message, Serialize, Deserialize)]
#[locality(&quot;Remote&quot;)]
struct MoveCommand(Vec3);
<span class="boring">}</span></code></pre></pre>
<p>The first line declare what macro we will be using for this component/container. Because we are making a message container for movement input, it will contain <code>Message</code>, <code>Serialize</code>, and <code>Deserialize</code> macro services. The second line <code>#[locality('Remote')]</code> states that how we have specified the <code>Locality</code> of this message type. <code>Local</code> messages are sent to other plugins on this host. <code>Remote</code> messages are sent to the remote host. For example, a <code>Remote</code> message sent from a client would be received <em>only</em> at the server. The last line will be the structure of the message container. Because we are sending just the direction, it will be a struct that only contains as a <code>Vec3</code>. We can change the format differently as below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add movement command as message from client to server
#[derive(Message, Serialize, Deserialize)]
#[locality(&quot;Remote&quot;)]
struct MoveCommand{
    direction: Vec3,
}
<span class="boring">}</span></code></pre></pre>
<p>This format will specify which attribute we want to call for later in the server side. As of now, we will stick with the first format, but there will be a note if there is a difference if someone else use the format above.</p>
<h3 id="creating-a-fire-input-message-container"><a class="header" href="#creating-a-fire-input-message-container">Creating a Fire Input Message Container</a></h3>
<p>With the same approach for the Movement Input Message, we also need to establish the fire input message container as well. The only input we need for this game is whether the &quot;shoot&quot; button has been triggered or not. Therefore the implementation of this message container will be the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add fire command as a message from client to server
#[derive(Message, Serialize, Deserialize)]
#[locality(&quot;Remote&quot;)]
struct FireCommand(bool);
<span class="boring">}</span></code></pre></pre>
<h2 id="user-input-movement"><a class="header" href="#user-input-movement">User Input Movement</a></h2>
<p>Now we need to create functions from both client side and server side for movement input. The client side will need to send the message to the server whereas the server side need to update the entity. The next two section will describe each side of the code. </p>
<h3 id="before-we-start-working-on-client-side"><a class="header" href="#before-we-start-working-on-client-side">Before we start working on client side...</a></h3>
<p>We need to add more crates into the plugin to add features such as keyboard/control input, frametime, and random number generator. In the beginning of the code, add/update the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add libraries from the cimvr_engine_interface crate
use cimvr_engine_interface::{make_app_state, pcg::Pcg, pkg_namespace, prelude::*, FrameTime};

// Add libraries from the cimvr_common crate
use cimvr_common::{
    desktop::{InputEvent, KeyCode},
    gamepad::{Axis, Button, GamepadState},
    glam::{EulerRot, Quat, Vec3},
    render::{Mesh, MeshHandle, Primitive, Render, UploadMesh, Vertex},
    utils::input_helper::InputHelper,
    Transform,
};
<span class="boring">}</span></code></pre></pre>
<h3 id="client-side"><a class="header" href="#client-side">Client Side</a></h3>
<p>Before we get into client side, we need to update the ClientState that will contain the keyboard input value. Update the component part of the <code>ClientState</code> as following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct ClientState {
    input: InputHelper,
}
<span class="boring">}</span></code></pre></pre>
<p>Inside the <code>new</code> function of the <code>ClientState</code>, we will be using the <code>EngineSchedule</code> argument to connect the functions to the engine.</p>
<p>Insert the following lines inside the <code>new</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ClientState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
// Add player movement input based on keyboard/controller input
        sched
            .add_system(Self::player_input_movement_update)
            .subscribe::&lt;InputEvent&gt;()
            .subscribe::&lt;GamepadState&gt;()
            .subscribe::&lt;FrameTime&gt;()
            .build();
        Self::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The first line is calling the <code>EngineSchedule</code> as <code>sched</code>. The second line will add the system to the engine schedule. We will write about the <code>player_input_movement_update</code> function in the next paragraph. But that function is declared inside the <code>ClientState</code>. The third line to fifth line, we will attach other feeatures. The features we are adding are <code>InputEvent</code>, <code>GamepadState</code>, and <code>FrameTime</code>. <code>InputEvent</code> is the connector between the client and the keyboard input. <code>GamepadState</code> is the connector between <strong>xBox</strong> controller and the client.  Lastly, <code>FrameTime</code> will read the frames based on the system setting; each system has their own framerate that it will change based on the frame rate. The last line will build that system with those feature attachments.</p>
<blockquote>
<p>Note: We only support <strong>xBox</strong> controller at this time. There are some controllers that might work, but we have not tested fully. Therefore, if there is an controller you want us to implement, please check out this <a href="https://github.com/ChatImproVR/chatimprovr/issues/85">issue</a> for updates. </p>
</blockquote>
<p>Now, lets implement the <code>player_input_movement_update</code> function. First, we need to implement in the <code>ClientState</code>. Within the <code>ClientState</code>, we will declare the function. The function default will take three arguments: <code>self</code>, <code>EngineIo</code>, and <code>QueryResult</code>. In this case, we are not using the <code>QueryResult</code> argument, so we can ignore the usage of that argument. You should have something similar as the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ClientState{
    fn player_input_movement_update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult){

    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now, let's fill the function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ClientState{
    fn player_input_movement_update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult){
        let mut direction = Vec3::ZERO;

        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };

        self.input.handle_input_events(io);

        let deadzone = 0.3;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The direction is declared as mutable since that value will change based on the input. The second line will read the frametime based on the <code>FrameTime</code> feature; it use the idea of <a href="https://chatimprovr.github.io/The-Book/Core_Concepts/pub_sub.html">subscribe and publish</a>. In short, it will read the first message that contains the FrameTime feature and will save it as frame_time. The third line initializes the input from the keyboard. If you are planning to take input from the keyboard, then you need to declare that statement before calling any keyboard input-related function. The value input is from the updated struct on the ClientState. The last line sets a dead zone for the controller. The controller dead zone is the amount your control stick can move before it's recognized in the game.</p>
<p>Now let's focus on input listener part:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Block 1
if let Some(GamepadState(gamepads)) = io.inbox_first() {
    if let Some(gamepad) = gamepads.into_iter().next() {
        if gamepad.axes[&amp;Axis::LeftStickX] &lt; -deadzone {
            direction += Vec3::new(-1.0, 0.0, 0.0);
        }
        if gamepad.axes[&amp;Axis::LeftStickX] &gt; deadzone {
                direction += Vec3::new(1.0, 0.0, 0.0);
        }
    }
}
// Block 2
else{
    if self.input.key_held(KeyCode::A) {
        direction += Vec3::new(-1.0, 0.0, 0.0);
    }

    if self.input.key_held(KeyCode::D) {
        direction += Vec3::new(1.0, 0.0, 0.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Block 1 focuses on controller input whereas Block 2 focuses on keyboard input.</p>
<p>Block 1 states that if there is message input that has the <code>GamepadState</code>, we will iter <code>Vec</code> of input of the gamepad. Inside that <code>Vec</code>, if there is a input from the left input from the left stick <code>gamepad.axes[&amp;Axis::LeftStickX]</code> and the value is more than the deadzone, it will update the <code>direction</code> by one unit to the left (x-axis). Same idea for positive value. We only want the player to only move left or right (no up and down). </p>
<p>With that same idea of Block 1, Block 2 use the same logic, but instead of gamepad, it will be <code>a</code> and <code>d</code> keyboard button to move left and right respectivly.</p>
<p>Now the last part of the client side. We need to create a message so that we will send it to the server. Take a look at the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if direction != Vec3::ZERO {
    let distance = direction.normalize() * frame_time.delta * PLAYER_SPEED;
    let command = MoveCommand(distance);
    io.send(&amp;command);
    }
<span class="boring">}</span></code></pre></pre>
<p>If the direction value is non-zero vector, then we will create a message since there was a player input. First, we need to update the value based on the frametime; let it called as <code>distance</code>. Next, we will use the custom made <code>MoveCommand</code> message and attach the <code>distance</code> value. Once that value is attached, then will will send that command to the engine which will transfer to the server. With all that, we have finished writing the movement function on the client side. The following code the complete side of the <code>ClientState</code> implementation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ClientState{
    // Send the player movement input to the server side
    fn player_input_movement_update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult) {
        let mut direction = Vec3::ZERO;

        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };

        self.input.handle_input_events(io);

        let deadzone = 0.3;

        if let Some(GamepadState(gamepads)) = io.inbox_first() {
            if let Some(gamepad) = gamepads.into_iter().next() {
                if gamepad.axes[&amp;Axis::LeftStickX] &lt; -deadzone {
                    direction += Vec3::new(-1.0, 0.0, 0.0);
                }
                if gamepad.axes[&amp;Axis::LeftStickX] &gt; deadzone {
                    direction += Vec3::new(1.0, 0.0, 0.0);
                }
            }
        } else {
            if self.input.key_held(KeyCode::A) {
                direction += Vec3::new(-1.0, 0.0, 0.0);
            }
            if self.input.key_held(KeyCode::D) {
                direction += Vec3::new(1.0, 0.0, 0.0);
            }
        }
        if direction != Vec3::ZERO {
            let distance = direction.normalize() * frame_time.delta * PLAYER_SPEED;
            let command = MoveCommand(distance);
            io.send(&amp;command);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to work on the server side.</p>
<h3 id="server-side"><a class="header" href="#server-side">Server Side</a></h3>
<p>With the same idea as the client side, we need to attach the function to the engine scheduler inside the <code>new</code> function on the <code>ServerState</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Attach Player Movement Function to the Engine schedule
        sched
            .add_system(Self::player_movement_update)
            .subscribe::&lt;MoveCommand&gt;()
            .query(
                &quot;Player_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Player&gt;(Access::Write),
            )
            .build();
        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The first line is the same sytax on the client side of adding a <code>player_movement_update</code> function to the system. We need to recieve input from the <code>MoveCommand</code> message; hence, we need to subscribe the <code>MoveCommand</code> message. Lastly, we need to add a <strong>query</strong>. Query is one of the most important concepts when it comes to server-side implementation. It will fetch all the entities that matches the conditions. The first parameter of the query function takes the name of the query; we will talk the importance of the naming the query in the other systems such as collision. The second parameter is the condition of the query. In this query, we want all the entities that has the <code>Player</code> component and <code>Transform</code> component. With those component, the function has permission to modify the component. If you want the component not to be modified, then we can simply change the permission from <code>Access::Write</code> to <code>Access::Read</code>. The last function is building just like the client side did. Now, lets switch our focus to the <code>player_movement_update</code> function.</p>
<p>First, we are going to implement the function inside the <code>ServerState</code> as the following: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    fn player_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult){

    }
}
<span class="boring">}</span></code></pre></pre>
<p>From there, we need to add the first condition such that we are going to execute the function if the message inbox has the <code>MoveCommand</code> like the following line.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for player_movement in io.inbox::&lt;MoveCommand&gt;(){

}
<span class="boring">}</span></code></pre></pre>
<p>The <code>player_movement</code> will be the iterator of the <code>io.inbox::&lt;MoveCommand&gt;()</code>. Since this statement is saying that we have an input from the client, we then need to modify the player movement. Now we need to go every entity that qualifies the condition. In the previous part, we have indicated that all entities that has the <code>Player</code> component and the <code>Transform</code> component will be modified. There is only one entity has those components which is the Player entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in query.iter(&quot;Player_Movement&quot;){}
<span class="boring">}</span></code></pre></pre>
<p>For future reference, if we have multiple queries, then we can differentiate based on the name of the query. There is more detailed information in <a href="Beginner_Tutorial/../Core_Concepts/entity_component_system.html">our docs on the entity component system</a> or in the system development. From there on, we can add conditions before actually moving the entity inside the query. For example, if the player is about to go out of bounds, then we need to stop that. We will first the current position of the player from the <code>Player</code> component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x_limit = WITDH / 2.0;
if query.read::&lt;Player&gt;(entity).current_position.x + player_movement.0.x - PLAYER_SIZE &lt; -x_limit
    || query.read::&lt;Player&gt;(entity).current_position.x + player_movement.0.x + PLAYER_SIZE &gt; x_limit
    {
        return;
    }
<span class="boring">}</span></code></pre></pre>
<p>If the player is about to go out of bounds, then we will do nothing with that input. Otherwise, we will change the player position based on the input, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>query.modify::&lt;Transform&gt;(entity, |transform| {
    transform.pos += player_movement.0;
});
<span class="boring">}</span></code></pre></pre>
<p>At the same time, we will also update the Player current position by modifying the <code>Player</code> component value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>query.modify::&lt;Player&gt;(entity, |player| {
    player.current_position += player_movement.0;
});
<span class="boring">}</span></code></pre></pre>
<p>With all that, we have completed set up the player movements for both server and client. The following code is the final part of the server side code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the player movement
    fn player_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for player_movement in io.inbox::&lt;MoveCommand&gt;() {
            for entity in query.iter(&quot;Player_Movement&quot;) {
                let x_limit = WITDH / 2.0;
                if query.read::&lt;Player&gt;(entity).current_position.x + player_movement.0.x - PLAYER_SIZE
                    &lt; -x_limit
                    || query.read::&lt;Player&gt;(entity).current_position.x + player_movement.0.x + PLAYER_SIZE
                        &gt; x_limit
                {
                    return;
                }

                query.modify::&lt;Transform&gt;(entity, |transform| {
                    transform.pos += player_movement.0;
                });
                query.modify::&lt;Player&gt;(entity, |player| {
                    player.current_position += player_movement.0;
                });
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="random-movement"><a class="header" href="#random-movement">Random Movement</a></h2>
<p>If we can make movements for the player, then we should add movements for the enemies as well. While we could set it up as client sending a message to the server side, for this purpose, let's set up only on the server side. In other words, we do not need to do use the <code>MoveCommand</code> message.</p>
<p>First, we need to attach the system call to the engine. The following would look very similar to the Player movement system.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
// Attach Enemy Movement Function to the Engine schedule
sched
    .add_system(Self::enemy_movement_update)
    .subscribe::&lt;FrameTime&gt;()
    .query(
        &quot;Enemy_Movement&quot;,
        Query::new()
            .intersect::&lt;Transform&gt;(Access::Write)
            .intersect::&lt;Enemy&gt;(Access::Write),
    )
    .build();
    Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The only differences are that there is no <code>subscribe</code> for <code>MoveCommand</code> but <code>subscribe</code> for <code>Frametime</code> and the query filter changed from <code>Player</code> to <code>Enemy</code>. We don't need to go into depth about this code, since we have seen this pattern before. In fact, most of the attachment to the engine will be the same, with the exception of the query part, which will be highlighted if needed in other systems.</p>
<p>Let's switch our focus to <code>enemy_movement_update</code> function that will be implemented in the <code>ServerState</code>. Because we are not looking at the inbox messages, we will look at every entity that qualifies the condition (the entity contains the <code>Transform' and </code>Enemy` component and mutable).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    fn enemy_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity in query.iter(&quot;Enemy_Movement&quot;){

        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>From there, we want to get the <code>Frametime</code>. Therefore, we will use this statement. This is the same line we used for the User Input Movement on the client side, but this time only for the server side.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };
<span class="boring">}</span></code></pre></pre>
<p>Next, we need to initialize our random number generators using the <code>Pcg</code> crate. Check out the docs on the Pcg crate <a href="https://docs.rs/pcg/latest/pcg/">here</a>, but it will be something like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pcg_random_move = Pcg::new();
let mut pcg_random_direction = Pcg::new();
<span class="boring">}</span></code></pre></pre>
<p>For this tutorial we created two separate random generator so that each part will have a different seed for different character of the movement: one random generator will be the magnitude, whereas the other one will be for the direction.</p>
<p>From there, we need to get values for <code>x</code> and <code>y</code> positions using the random generator. We will conditions to generate these values like the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = if pcg_random_direction.gen_bool() {
    pcg_random_move.gen_f32() * 1.
} else {
    pcg_random_move.gen_f32() * -1.
};

let y = if pcg_random_direction.gen_bool() {
    pcg_random_move.gen_f32() * 1.
} else {
    pcg_random_move.gen_f32() * -1.
};

let speed = Vec3::new(x, y, 0.);

let direction = speed.normalize() * frame_time.delta * ENEMY_SPEED;
<span class="boring">}</span></code></pre></pre>
<p>Once the <code>x</code> and <code>y</code> values are automatically generated, then we will declare the direction as a <code>Vec3</code> format while considering the <code>frame_time</code> and <code>ENEMY_SPEED</code>.</p>
<p>With the same logic as <code>player_movement_update</code>, we will read the current position of that enemy and check whether that move is valid within bound (and vertical limitations). If it is valid, then we will move accordingly by modifying the <code>Transform</code> component and update the new position of the enemy in the <code>Enemy</code> component. Otherwise, nothing will happen. That being said, the following code will be the complete side of the random movement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the enemy movement
    fn enemy_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity in query.iter(&quot;Enemy_Movement&quot;) {
            let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };
            let mut pcg_random_move = Pcg::new();
            let mut pcg_random_direction = Pcg::new();

            let x = if pcg_random_direction.gen_bool() {
                pcg_random_move.gen_f32() * 1.
            } else {
                pcg_random_move.gen_f32() * -1.
            };

            let y = if pcg_random_direction.gen_bool() {
                pcg_random_move.gen_f32() * 1.
            } else {
                pcg_random_move.gen_f32() * -1.
            };

            let speed = Vec3::new(x, y, 0.);

            let direction = speed.normalize() * frame_time.delta * ENEMY_SPEED;

            let x_limit = WITDH / 2.0;
            let y_upper_limit = HEIGHT / 2.;
            let y_limit = HEIGHT / 5.;

            let current_position = query.read::&lt;Enemy&gt;(entity).current_position;

            if (current_position.x + direction.x - ENEMY_SIZE &lt; -x_limit)
                || (current_position.x + direction.x + ENEMY_SIZE &gt; x_limit)
                || (current_position.y + direction.y &gt;= y_upper_limit)
                || (current_position.y + direction.y &lt; y_limit)
            {
                return;
            }
            query.modify::&lt;Transform&gt;(entity, |transform| {
                transform.pos += direction;
            });
            query.modify::&lt;Enemy&gt;(entity, |enemy| {
                enemy.current_position += direction;
            });
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fire-system"><a class="header" href="#fire-system">Fire System</a></h2>
<p>We can implement the same method for User Input for player fire system, and the enemy will have the same idea for random movement but fire rate. However, we do not have the bullet entity. Let's take a look into these systems for both player and enemy:</p>
<h3 id="player-fire-client-system"><a class="header" href="#player-fire-client-system">Player Fire Client System</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ClientState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {   
        // Add player fire input based on keyboard/controller input
        sched
            .add_system(Self::player_input_fire_update)
            .subscribe::&lt;InputEvent&gt;()
            .subscribe::&lt;GamepadState&gt;()
            .build();
        Self::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With the same idea of movement input, we will subscribe the <code>InputEvent</code> and <code>GamepadState</code> to take input for both controller and keyboard. This code will be in the <code>new</code> function in the <code>ClientState</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ClientState{
    // Send the player fire input to the server side
    fn player_input_fire_update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult) {
        self.input.handle_input_events(io);

        if let Some(GamepadState(gamepads)) = io.inbox_first() {
            if let Some(gamepad) = gamepads.into_iter().next() {
                if gamepad.buttons[&amp;Button::East] {
                    let command = FireCommand(true);
                    io.send(&amp;command);
                }
            }
        }

        if self.input.key_pressed(KeyCode::Space) {
            let command = FireCommand(true);
            io.send(&amp;command);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the code above, we set the client side if the space bar was triggered or the east side button on the right side is triggered. The <code>gamepad.buttons[&amp;Button::East]</code> indicates the east button on the right side. You can find more button information in the engine implementation.</p>
<h3 id="player-fire-server-system"><a class="header" href="#player-fire-server-system">Player Fire Server System</a></h3>
<p>For bullets, we need to implement two functions on the <code>ServerState</code>: a function for generating the bullets and a function for moving the bullets. Therefore, we have two systems to attach the engine.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
        fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Attach Player Fire Function to the Engine schedule
        sched
            .add_system(Self::player_fire_update)
            .subscribe::&lt;FireCommand&gt;()
            .query(
                &quot;Player_Fire_Input&quot;,
                Query::new().intersect::&lt;Player&gt;(Access::Read),
            )
            .build();

        // Attach Player Bullet Movement Function to the Engine schedule
        sched
            .add_system(Self::player_bullet_movement_update)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Player_Bullet_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .build();
        Self
    }
}

<span class="boring">}</span></code></pre></pre>
<p>The first system is reading if there is a <code>FireCommand</code> from the client side in order to fire the system. The query for the first system only needs to read the player's current position in order to shoot the bullet from player's current position from the <code>Player</code> component. The second system is moving the player's bullet. The query for this system will be the same idea for any movement system: the system needs <code>Transform</code> component and <code>Bullet</code> component. Let's take a look at the <code>player_fire_update</code> function first.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the player fire
    fn player_fire_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        if let Some(FireCommand(_value)) = io.inbox_first() {
            for entity in query.iter(&quot;Player_Fire_Input&quot;) {
                // Create the bullet entity from the player position (the left bullet)
                io.create_entity()
                    .add_component(
                        Render::new(PLAYER_BULLET_HANDLE).primitive(Primitive::Triangles),
                    )
                    .add_component(Synchronized)
                    .add_component(Bullet {
                        from_enemy: false,
                        from_player: true,
                        entity_id: entity,
                    })
                    .add_component(Transform::default().with_position(
                        query.read::&lt;Player&gt;(entity).current_position
                            + Vec3::new(-PLAYER_SIZE / 2., PLAYER_SIZE / 2., 0.0),
                    ))
                    .build();

                // Create the bullet entity from the player position (the right bullet)
                io.create_entity()
                    .add_component(
                        Render::new(PLAYER_BULLET_HANDLE).primitive(Primitive::Triangles),
                    )
                    .add_component(Synchronized)
                    .add_component(Bullet {
                        from_enemy: false,
                        from_player: true,
                        entity_id: entity,
                    })
                    .add_component(Transform::default().with_position(
                        query.read::&lt;Player&gt;(entity).current_position
                            + Vec3::new(PLAYER_SIZE / 2., PLAYER_SIZE / 2., 0.0),
                    ))
                    .build();
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see the code above, we can create new entities inside the function; therefore, we do not need to create the bullet entities inside the <code>new</code> function because we do not need to load the bullet in the scene at the beginning. We created two bullet entities so that the player can shoot from top left and top right side of the player's current position. Now, let's take a look at the player's bullet movement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the player bullet movement
    fn player_bullet_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };

        for entity in query.iter(&quot;Player_Bullet_Movement&quot;) {
            if query.read::&lt;Bullet&gt;(entity).from_player {
                if query.read::&lt;Transform&gt;(entity).pos.y &gt; HEIGHT / 2. - 2.5 {
                    io.remove_entity(entity);
                }
                query.modify::&lt;Transform&gt;(entity, |transform| {
                    transform.pos +=
                        Vec3::new(0.0, 1.0, 0.0) * frame_time.delta * PLAYER_BULLET_SPEED;
                });
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The first line inside the function is the same line to read the <code>frame_time</code> value. For the every bullet from the player, if the bullet is out of bound from the scene, then remove that bullet from the screen. Otherwise, we will move the bullet one unit up to the Y-axis with the custom set speed for the player's bullet. As you read the code, it is very similar to movement for player and enemy. Let's switch our intention to <code>Enemy</code> since I have added some complexity to bullet fire rate.</p>
<h3 id="enemy-fire-server-system"><a class="header" href="#enemy-fire-server-system">Enemy Fire Server System</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
        fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Attach Enemy Fire Function to the Engine schedule
        sched
            .add_system(Self::enemy_fire_update)
            .query(
                &quot;Enemy_Fire_Input&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();

        // Attach Enemy Bullet Movement Function to the Engine schedule
        sched
            .add_system(Self::enemy_bullet_movement_update)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Enemy_Bullet_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .query(
                &quot;Enemy_Bullet_Count_Update&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();
        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the first system attachment, it is the same idea what we did for player's bullet. The only difference is that we are reading from <code>Enemy</code> component rather than <code>Player</code> component. The second system attachment is very different; rather not having one query, but two quries. The first query will fetch all entities that has the <code>Bullet</code> and <code>Transform</code> components and modify it whereas the second query will only read from the <code>Enemy</code> component. Let's take a look at the <code>enemy_fire_update</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the enemy fire update
    fn enemy_fire_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let mut pcg_fire = Pcg::new();

        for entity in query.iter(&quot;Enemy_Fire_Input&quot;) {
            if pcg_fire.gen_bool() {
                if query.read::&lt;Enemy&gt;(entity).bullet_count &lt; ENEMY_MAX_BULLET {
                    // Increase the bullet count that are on screen from that enemy by 1
                    query.modify::&lt;Enemy&gt;(entity, |value| {
                        value.bullet_count += 1;
                    });
                    io.create_entity()
                        .add_component(
                            Render::new(ENEMY_BULLET_HANDLE).primitive(Primitive::Triangles),
                        )
                        .add_component(Synchronized)
                        .add_component(Bullet {
                            from_enemy: true,
                            from_player: false,
                            entity_id: entity,
                        })
                        .add_component(Transform::default().with_position(
                            query.read::&lt;Enemy&gt;(entity).current_position
                                + Vec3::new(0., -ENEMY_SIZE / 2., 0.),
                        ))
                        .build();
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When you first look at this function, you will notice a lot of similarity from the <code>player_fire_update</code> function. However, before creating the enemy's bullet entity, we have to add a condition on enemy's bullet display limit. We have this limitation because it will be almost impossible to play since it will continously spamming bullets that the player will not even have a chance to kill the enemy. Therefore, if there is more bullets than <code>ENEMY_MAX_BULLET</code> value from each enemy, then it will not generate a new one until the bullet is gone from the scene (either from hitting the player or going out of bound). Therefore, we will read the current bullet amount on the screen from the <code>Enemy</code> component. We will modify that value in the next function. At the same time, when we generate the bullet, we will store the <code>parent entities id</code>. This value is important in the next function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the enemy bullet movement
    fn enemy_bullet_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        if let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() {
            for entity in query.iter(&quot;Enemy_Bullet_Movement&quot;) {
                if query.read::&lt;Bullet&gt;(entity).from_enemy {
                    if query.read::&lt;Transform&gt;(entity).pos.y &lt; -HEIGHT / 2. + 2.5 {
                        if query
                            .iter(&quot;Enemy_Bullet_Count_Update&quot;)
                            .any(|id| id == query.read::&lt;Bullet&gt;(entity).entity_id)
                        {
                            query.modify::&lt;Enemy&gt;(
                                query.read::&lt;Bullet&gt;(entity).entity_id,
                                |value| {
                                    value.bullet_count -= 1;
                                },
                            );
                        }
                        io.remove_entity(entity);
                    }
                    query.modify::&lt;Transform&gt;(entity, |transform| {
                        transform.pos +=
                            Vec3::new(0.0, -1.0, 0.0) * frame_time.delta * ENEMY_BULLET_SPEED;
                    });
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function is similar to the player_bullet_movement_update function but has an additional bullet counter on the screen and updater. Let's take a look at the query that states Enemy_Bullet_Count_Update. The condition states that we need to find the parent (the enemy) and check if that enemy is alive. If the enemy is alive, then we update the bullet_count value by 1; otherwise, we ignore it since that enemy is dead. Once that is complete, we remove the bullet from the screen. You can customize the option on how to implement the bullet limitation, but we need to use the concept of parenting between entities.</p>
<p>Now we have a system that can shoot and move, but what's the fun in that? We need to add collision detection between entities. If a bullet hits a player or enemy, it should be removed. After a certain amount of time has passed since its death, the player or enemy should respawn. Once that is set up, we will have a game-like Galaga in our hands.</p>
<h2 id="collision"><a class="header" href="#collision">Collision</a></h2>
<p>First, let's work on collision. There are two types of collision in Galaga: where the player's bullet hits an enemy, and where an enemy's bullet hits the player. But before that, lets make a collision function so that we do not need to rewrite the same collision code multiple times.</p>
<h3 id="collision-function"><a class="header" href="#collision-function">Collision Function</a></h3>
<p>This function is based off from standard, classic game logic of collision.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The function that will handle the collision detection
fn collision_detection(
    obj1_x_position: f32,
    obj1_y_position: f32,
    obj1_size: f32,
    obj2_x_position: f32,
    obj2_y_position: f32,
    obj2_size: f32,
) -&gt; bool {
    // If the object 1 is within the object 2 based on the sqaure hitbox intersection
    if obj1_x_position - (obj1_size / 2.) &lt;= obj2_x_position + (obj2_size / 2.)
        &amp;&amp; obj1_x_position + (obj1_size / 2.) &gt;= obj2_x_position - (obj2_size / 2.)
        &amp;&amp; (obj1_y_position - (obj1_size / 2.) &lt;= obj2_y_position + (obj2_size / 2.))
        &amp;&amp; (obj1_y_position + (obj1_size / 2.) &gt;= obj2_y_position - (obj2_size / 2.))
    {
        // Return true if the object 1 is within the object 2, or vice versa
        return true;
    }
    // Otherwise, return false
    return false;
}
<span class="boring">}</span></code></pre></pre>
<p>We do not need to fully understand how the logic works, but we need to understand the input/arguments of the function. The <code>x</code> and <code>y</code> positions of the object/entity are defined as the center (not at the bottom left, which is how most engines handle it). The <code>size</code> argument identifies the length between the left side and the right side. In other words, we are defining the entity/object as a square. If these two squares overlap each other, then we consider it a collision and return that they are hitting each other; otherwise, it is not a collision.</p>
<h3 id="player-bullet-to-enemy"><a class="header" href="#player-bullet-to-enemy">Player Bullet to Enemy</a></h3>
<p>First, we need to attach the function with the right quries. We need two quries for collision: one for the player bullet and the enemy. The following code will capture those entities.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self{
        // Attach Player Bullet to Enemy Collision Function to the Engine schedule
        sched
            .add_system(Self::player_bullet_to_enemy_collision)
            .query(
                &quot;Player_Bullet&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Read)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .query(
                &quot;Enemy&quot;,
                Query::new()
                    .intersect::&lt;Enemy&gt;(Access::Write)
                    .intersect::&lt;Transform&gt;(Access::Read),
            )
            .build();
        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There is nothing much unique than other system attachment as the previous one. Therefore, we are not going in depth about this code anymore due to the redundancy. </p>
<p>Now, lets take a look at the <code>player_bullet_to_enemy_collision</code> function as below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will handle the collision from player bullet to enemy
    fn player_bullet_to_enemy_collision(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity1 in query.iter(&quot;Player_Bullet&quot;) {
            if query.read::&lt;Bullet&gt;(entity1).from_player {
                for entity2 in query.iter(&quot;Enemy&quot;) {
                    let current_player_bullet = query.read::&lt;Transform&gt;(entity1).pos;
                    let current_enemy = query.read::&lt;Transform&gt;(entity2).pos;

                    // If the bullet hit the enemy
                    if collision_detection(
                        current_player_bullet.x,
                        current_player_bullet.y,
                        BULLET_SIZE,
                        current_enemy.x,
                        current_enemy.y,
                        ENEMY_SIZE,
                    ) {
                        io.remove_entity(entity1);
                        io.remove_entity(entity2);
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>First, we check if the player bullet exists. If it does, then we check if the enemy entity exists. After that, we compare the positions of these entities and check if they have a collision using the previous function <code>collision_detection</code>. If a collision is detected, we remove the entities. This process is straightforward without any abstract meaning behind it. In this context, <code>entity1</code> refers to the player bullet, while <code>entity2</code> refers to the enemy.</p>
<h3 id="enemy-bullet-to-player"><a class="header" href="#enemy-bullet-to-player">Enemy Bullet to Player</a></h3>
<p>However, enemy bullet to player collision is slightly different because not only we need to handle bullet limitation, but also respawning part for the player. Take a look at the following code below.</p>
<blockquote>
<p>Note: Respawning for the enemy is coded differently so that the previous code do not need to modify as the following; however, you are welcome to do in that way.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self{
        // Attach Enemy Bullet to Player Collision Function to the Engine schedule
        sched
            .add_system(Self::enemy_bullet_to_player_collision)
            .query(
                &quot;Enemy_Bullet&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Read)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .query(
                &quot;Player&quot;,
                Query::new()
                    .intersect::&lt;Player&gt;(Access::Write)
                    .intersect::&lt;Transform&gt;(Access::Read),
            )
            .query(
                &quot;Player_Status_Update&quot;,
                Query::new().intersect::&lt;PlayerStatus&gt;(Access::Write),
            )
            .query(
                &quot;Enemy_Bullet_Count_Update&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();
        Self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rather than having two quries from previous example, we need to use four different quries: one for the enemy bullet, one for the player, one for the player status (which we will talk about it in a moment), and the enemy for counting the bullet on screen. Let's take a look at the following code for <code>enemy_bullet_to_player_collision</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
        // The function that will handle the collision from enemy bullet to player
    fn enemy_bullet_to_player_collision(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity1 in query.iter(&quot;Enemy_Bullet&quot;) {
            if query.read::&lt;Bullet&gt;(entity1).from_enemy {
                for entity2 in query.iter(&quot;Player&quot;) {
                    let current_enemy_bullet = query.read::&lt;Transform&gt;(entity1).pos;
                    let current_player = query.read::&lt;Transform&gt;(entity2).pos;

                    // If the bullet hit the player
                    if collision_detection(
                        current_enemy_bullet.x,
                        current_enemy_bullet.y,
                        BULLET_SIZE,
                        current_player.x,
                        current_player.y,
                        PLAYER_SIZE,
                    ) {
                        if query
                            .iter(&quot;Enemy_Bullet_Count_Update&quot;)
                            .any(|id| id == query.read::&lt;Bullet&gt;(entity1).entity_id)
                        {
                            query.modify::&lt;Enemy&gt;(
                                query.read::&lt;Bullet&gt;(entity1).entity_id,
                                |value| {
                                    value.bullet_count -= 1;
                                },
                            );
                        }
                        io.remove_entity(entity1);
                        io.remove_entity(entity2);
                        for entity3 in query.iter(&quot;Player_Status_Update&quot;) {
                            query.modify::&lt;PlayerStatus&gt;(entity3, |value| {
                                value.status = false;
                            });
                        }
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can find similarities between the <code>player_bullet_to_enemy_collision</code> function; however, there is more code than that function. First, if collision is detected, then we need to update the bullet count for that enemy by one since that bullet will be remove from the collision of the player. Another thing we have a difference is the status of the player is consider as dead, which it is <code>False</code>. This value will be used for respawning the player entity. <code>entity1</code> is the enemy bullet whereas <code>entity2</code> is the player.</p>
<h3 id="respawning-player"><a class="header" href="#respawning-player">Respawning Player</a></h3>
<p>For attaching the respawning the player, we only need to check teh PlayerStatus; we just need to know if the player is dead or alive.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Attach Spawn Player Function to the Engine schedule
        sched
            .add_system(Self::spawn_player)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Player&quot;,
                Query::new().intersect::&lt;PlayerStatus&gt;(Access::Write),
            )
            .build();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's take a look at the <code>spawn_player</code> function below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will spawn the player
    fn spawn_player(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };
        for entity in query.iter(&quot;Player&quot;) {
            if !(query.read::&lt;PlayerStatus&gt;(entity).status) {
                let mut dead_time = query.read::&lt;PlayerStatus&gt;(entity).dead_time;
                if dead_time == 0.0 {
                    dead_time = frame_time.time;
                }
                if dead_time + PLAYER_SPAWN_TIME &lt; frame_time.time {
                    io.create_entity()
                        .add_component(
                            Transform::default()
                                .with_position(Vec3::new(0.0, -50.0, 0.0))
                                .with_rotation(Quat::from_euler(EulerRot::XYZ, PI / 2., 0., 0.)),
                        )
                        .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
                        .add_component(Player::default())
                        .add_component(Synchronized)
                        .build();
                    io.remove_entity(entity);
                    io.create_entity()
                        .add_component(PlayerStatus::default())
                        .build();
                }
                else {
                    query.modify::&lt;PlayerStatus&gt;(entity, |value| {
                        value.dead_time = dead_time;
                    })
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>First, we are setting up a timer. This function will first trigger (or pass the first condition) if the player status is dead (<code>False</code>). We will store the time of the player's death in the <code>PlayerStatus</code> component. Then will will re-run the function since there is a <code>PlayerStatus</code> component that is <code>False</code> with the actual time that the player is dead. If a certain amount of time has passed since the player has been dead, then it will respawn at its original position. At the same time, we throw away the old <code>PlayerStatus</code> entity and create a nn case you haven't noticed, all the functions on the server and client side are continously running back of the scene and see if there are any changes that will trigger certain functions based on each entity conditions.</p>
<h3 id="respawning-enemy"><a class="header" href="#respawning-enemy">Respawning Enemy</a></h3>
<p>Let's switch our focus on the Enemy respawning part. Rather than reading the one query, we need to read two quries. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl UserState for ServerState{
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self{
        // Attach Spawn Enemy Function to the Engine schedule
        sched
            .add_system(Self::spawn_enemy)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Enemy_Count&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .query(
                &quot;Enemy_Status&quot;,
                Query::new().intersect::&lt;EnemyStatus&gt;(Access::Write),
            )
            .build();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Enemy_Count</code> query will count how many enemies exist on the scene. The <code>Enemy_Status</code> is the timer for respawning; same idea as the <code>PlayerStatus</code> component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ServerState{
    // The function that will spawn the enemy
    fn spawn_enemy(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return }
        if (query.iter(&quot;Enemy_Count&quot;).count() as u32) &lt; ENEMY_COUNT {
            for entity in query.iter(&quot;Enemy_Status&quot;) {
                let mut dead_time = query.read::&lt;EnemyStatus&gt;(entity).0;

                if dead_time == 0.0 {
                    dead_time = frame_time.time;
                }

                if dead_time + ENEMY_SPAWN_TIME &lt; frame_time.time {
                    io.create_entity()
                        .add_component(
                            Transform::default()
                                .with_position(Vec3::new(0.0, 50.0, 0.0))
                                .with_rotation(Quat::from_euler(EulerRot::XYZ, PI / 2., 0., 0.)),
                        )
                        .add_component(Render::new(ENEMY_HANDLE).primitive(Primitive::Lines))
                        .add_component(Synchronized)
                        .add_component(Enemy::default())
                        .build();
                    io.remove_entity(entity);
                    io.create_entity().add_component(EnemyStatus(0.0)).build();
                }
                else {
                    query.modify::&lt;EnemyStatus&gt;(entity, |value| {
                        value.0 = dead_time;
                    })
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Compare to the <code>spawn_player</code> function, the <code>spawn_enemy</code> will check how enemies exist on the scene. If there is less than maximum amount of enemies on the scene (<code>ENEMY_COUNT</code>), then we need to spawn a new enemy. Nevertheless, we do not want to spawn the enemy immediately after its death from a different enemy; we want some cool down time for the enemy as well. Therefore, we will use the <code>EnemyStatus</code> component as a timer. With the same logic as the <code>PlayerStatus</code> component, we will record the time when the enemy is dead and check if a certain amount of time has passed. If so, then generate a new enemy and reset (delete and set a new one) the <code>EnemyStatus</code> entity.</p>
<h2 id="summarycurrent-code-progress-1"><a class="header" href="#summarycurrent-code-progress-1">Summary/Current Code Progress</a></h2>
<p>That being said, we are mostly done with the Galaga game development. You should have something similar to this code below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f32::consts::PI;

// Add libraries from the cimvr_engine_interface crate
use cimvr_engine_interface::{make_app_state, pcg::Pcg, pkg_namespace, prelude::*, FrameTime};

// Add libraries from the cimvr_common crate
use cimvr_common::{
    desktop::{InputEvent, KeyCode},
    gamepad::{Axis, Button, GamepadState},
    glam::{EulerRot, Quat, Vec3},
    render::{Mesh, MeshHandle, Primitive, Render, UploadMesh, Vertex},
    utils::input_helper::InputHelper,
    Transform,
};

// Add libraries from the obj_reader crate
use obj_reader::obj::obj_lines_to_mesh;

// Add libraries from the serde crate
use serde::{Deserialize, Serialize};

// Create some constant value for Windows
const WITDH: f32 = 80.;
const HEIGHT: f32 = 120.;

// Create some constant values for Enemy
const ENEMY_COUNT: u32 = 2;
const ENEMY_MAX_BULLET: u32 = 5;
const ENEMY_SPAWN_TIME: f32 = 0.5;
const ENEMY_BULLET_SPEED: f32 = 100.;
const ENEMY_SPEED: f32 = 50.;
const ENEMY_SIZE: f32 = 3.; // Because of the obj file, this value is not used (update this value after changing the obj size)

// Create some constant values for Player
const PLAYER_SPAWN_TIME: f32 = 3.0;
const PLAYER_BULLET_SPEED: f32 = 100.;
const PLAYER_SPEED: f32 = 100.;
const PLAYER_SIZE: f32 = 3.; // Because of the obj file, this value is not used (update this value after changing the obj size)

// Create some constant values for Bullet
const BULLET_SIZE: f32 = 0.5;

// All state associated with client-side behaviour
#[derive(Default)]
struct ClientState {
    input: InputHelper,
}

// Add movement command as message from client to server
#[derive(Message, Serialize, Deserialize)]
#[locality(&quot;Remote&quot;)]
struct MoveCommand(Vec3);

// Add fire command as a message from client to server
#[derive(Message, Serialize, Deserialize)]
#[locality(&quot;Remote&quot;)]
struct FireCommand(bool);

// Add Player Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Player {
    pub current_position: Vec3,
}

// Implement Default for Player Component
impl Default for Player {
    fn default() -&gt; Self {
        Self {
            current_position: Vec3::new(0.0, -50.0, 0.0),
        }
    }
}

// Add Enemy Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Enemy {
    pub current_position: Vec3,
    pub bullet_count: u32,
}

// Implement Default for Enemy Component
impl Default for Enemy {
    fn default() -&gt; Self {
        Self {
            current_position: Vec3::new(0.0, 50.0, 0.0),
            bullet_count: 0,
        }
    }
}

// Add Bullet Component
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct Bullet {
    from_player: bool,
    from_enemy: bool,
    entity_id: EntityId,
}

// Implement Default for Bullet Component
impl Default for Bullet {
    fn default() -&gt; Self {
        Self {
            from_player: false,
            from_enemy: false,
            entity_id: EntityId(0),
        }
    }
}

// Add Player Status Component; this is used as a spwan timer for Player
#[derive(Component, Serialize, Deserialize, Copy, Clone)]
pub struct PlayerStatus {
    pub status: bool,
    pub dead_time: f32,
}

// Implement Default for Player Status Component
impl Default for PlayerStatus {
    fn default() -&gt; Self {
        Self {
            status: true,
            dead_time: 0.0,
        }
    }
}

// Add Enemy Status Component; this is used as a spwan timer for Enemy
#[derive(Component, Serialize, Deserialize, Copy, Clone, Default)]
pub struct EnemyStatus(f32);

// Create mesh handleer based on each object's name
const PLAYER_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player&quot;));
const ENEMY_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy&quot;));
const PLAYER_BULLET_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player Bullet&quot;));
const ENEMY_BULLET_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy Bullet&quot;));
const WINDOW_SIZE_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Window Size&quot;));

// Create Player Bullet Mesh as a sqaure green
fn player_bullet() -&gt; Mesh {
    let size: f32 = BULLET_SIZE;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([size, -size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([size, size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([-size, size, 0.0], [0.0, 1.0, 0.0]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

    Mesh { vertices, indices }
}

// Create Enemy Bullet Mesh as a sqaure red
fn enemy_bullet() -&gt; Mesh {
    let size: f32 = BULLET_SIZE;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([size, -size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([size, size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([-size, size, 0.0], [1.0, 0.0, 0.0]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

    Mesh { vertices, indices }
}

// Create Window Mesh so that the users will know what is the limit of movement
fn window_size() -&gt; Mesh {
    let vertices = vec![
        Vertex::new([-WITDH / 2., -HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([WITDH / 2., -HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([WITDH / 2., HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([-WITDH / 2., HEIGHT / 2., 0.0], [1.; 3]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 0, 1, 1, 2, 2, 3];

    Mesh { vertices, indices }
}

// Create a struct for the Client State
impl UserState for ClientState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Declare the player color as green
        let player_color = [0., 1., 0.];

        // Read the player object file from the assets folder (that is created from blender)
        let mut new_player_mesh = obj_lines_to_mesh(&amp;include_str!(&quot;assets/galagaship.obj&quot;));

        // Update the player object/mesh with the player color
        new_player_mesh
            .vertices
            .iter_mut()
            .for_each(|v| v.uvw = player_color);

        // Declare the enemy color as red
        let enemy_color = [1., 0., 0.];

        // Read the enemy object file from the assets folder (that is created from blender)
        let mut new_enemy_mesh = obj_lines_to_mesh(&amp;include_str!(&quot;assets/galaga_enemy.obj&quot;));

        // Update the enemy object/mesh with the enemy color
        new_enemy_mesh
            .vertices
            .iter_mut()
            .for_each(|v| v.uvw = enemy_color);

        // Send the player mesh and the player mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: PLAYER_HANDLE,
            mesh: new_player_mesh,
        });

        // Send the enemy mesh and the enemy mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: ENEMY_HANDLE,
            mesh: new_enemy_mesh,
        });

        // Send the player bullet mesh and the player bullet mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: PLAYER_BULLET_HANDLE,
            mesh: player_bullet(),
        });

        // Send the enemy bullet mesh and the enemy bullet mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: ENEMY_BULLET_HANDLE,
            mesh: enemy_bullet(),
        });

        // Send the window mesh and the window mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: WINDOW_SIZE_HANDLE,
            mesh: window_size(),
        });

        // Add player movement input based on keyboard/controller input
        sched
            .add_system(Self::player_input_movement_update)
            .subscribe::&lt;InputEvent&gt;()
            .subscribe::&lt;GamepadState&gt;()
            .subscribe::&lt;FrameTime&gt;()
            .build();

        // Add player fire input based on keyboard/controller input
        sched
            .add_system(Self::player_input_fire_update)
            .subscribe::&lt;InputEvent&gt;()
            .subscribe::&lt;GamepadState&gt;()
            .build();

        Self::default()
    }
}

// Implement client only side functions that will send messages to the server side
impl ClientState {
    // Send the player movement input to the server side
    fn player_input_movement_update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult) {
        let mut direction = Vec3::ZERO;

        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };

        self.input.handle_input_events(io);

        let deadzone = 0.3;

        if let Some(GamepadState(gamepads)) = io.inbox_first() {
            if let Some(gamepad) = gamepads.into_iter().next() {
                if gamepad.axes[&amp;Axis::LeftStickX] &lt; -deadzone {
                    direction += Vec3::new(-1.0, 0.0, 0.0);
                }

                if gamepad.axes[&amp;Axis::LeftStickX] &gt; deadzone {
                    direction += Vec3::new(1.0, 0.0, 0.0);
                }
            }

            if self.input.key_held(KeyCode::A) {
                direction += Vec3::new(-1.0, 0.0, 0.0);
            }

            if self.input.key_held(KeyCode::D) {
                direction += Vec3::new(1.0, 0.0, 0.0);
            }

            if direction != Vec3::ZERO {
                let distance = direction.normalize() * frame_time.delta * PLAYER_SPEED;

                let command = MoveCommand(distance);

                io.send(&amp;command);
            }
        }
    }

    // Send the player fire input to the server side
    fn player_input_fire_update(&amp;mut self, io: &amp;mut EngineIo, _query: &amp;mut QueryResult) {
        self.input.handle_input_events(io);

        if let Some(GamepadState(gamepads)) = io.inbox_first() {
            if let Some(gamepad) = gamepads.into_iter().next() {
                if gamepad.buttons[&amp;Button::East] {
                    let command = FireCommand(true);
                    io.send(&amp;command);
                }
            }
        }

        if self.input.key_pressed(KeyCode::Space) {
            let command = FireCommand(true);
            io.send(&amp;command);
        }
    }
}

// All state associated with server-side behaviour
struct ServerState;

// Implement server only side functions that will update on the server side
impl UserState for ServerState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Create a player status entity (not player entity)
        io.create_entity()
            .add_component(PlayerStatus::default())
            .build();

        // Create an enemy status entity (not enemy entity)
        io.create_entity().add_component(EnemyStatus(0.0)).build();

        // Create Player entity with components
        io.create_entity()
            .add_component(
                Transform::default()
                    .with_position(Vec3::new(0.0, -50.0, 0.0))
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, PI / 2., 0., 0.)),
            )
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            .add_component(Player::default())
            .add_component(Synchronized)
            .build();

        // Create Enemy with components
        io.create_entity()
            .add_component(
                Transform::default()
                    .with_position(Vec3::new(0.0, 50.0, 0.0))
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, PI / 2., 0., 0.)),
            )
            .add_component(Render::new(ENEMY_HANDLE).primitive(Primitive::Lines))
            .add_component(Synchronized)
            .add_component(Enemy::default())
            .build();

        // Create the Window entity with components
        io.create_entity()
            .add_component(Transform::default())
            .add_component(Render::new(WINDOW_SIZE_HANDLE).primitive(Primitive::Lines))
            .add_component(Synchronized)
            .build();

        // Attach Spawn Player Function to the Engine schedule
        sched
            .add_system(Self::spawn_player)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Player&quot;,
                Query::new().intersect::&lt;PlayerStatus&gt;(Access::Write),
            )
            .build();

        // Attach Spawn Enemy Function to the Engine schedule
        sched
            .add_system(Self::spawn_enemy)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Enemy_Count&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .query(
                &quot;Enemy_Status&quot;,
                Query::new().intersect::&lt;EnemyStatus&gt;(Access::Write),
            )
            .build();

        // Attach Player Movement Function to the Engine schedule
        sched
            .add_system(Self::player_movement_update)
            .subscribe::&lt;MoveCommand&gt;()
            .query(
                &quot;Player_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Player&gt;(Access::Write),
            )
            .build();

        // Attach Enemy Movement Function to the Engine schedule
        sched
            .add_system(Self::enemy_movement_update)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Enemy_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();

        // Attach Player Fire Function to the Engine schedule
        sched
            .add_system(Self::player_fire_update)
            .subscribe::&lt;FireCommand&gt;()
            .query(
                &quot;Player_Fire_Input&quot;,
                Query::new().intersect::&lt;Player&gt;(Access::Read),
            )
            .build();

        // Attach Player Bullet Movement Function to the Engine schedule
        sched
            .add_system(Self::player_bullet_movement_update)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Player_Bullet_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .build();

        // Attach Enemy Fire Function to the Engine schedule
        sched
            .add_system(Self::enemy_fire_update)
            .query(
                &quot;Enemy_Fire_Input&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();

        // Attach Enemy Bullet Movement Function to the Engine schedule
        sched
            .add_system(Self::enemy_bullet_movement_update)
            .subscribe::&lt;FrameTime&gt;()
            .query(
                &quot;Enemy_Bullet_Movement&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Write)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .query(
                &quot;Enemy_Bullet_Count_Update&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();

        // Attach Player Bullet to Enemy Collision Function to the Engine schedule
        sched
            .add_system(Self::player_bullet_to_enemy_collision)
            .query(
                &quot;Player_Bullet&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Read)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .query(
                &quot;Enemy&quot;,
                Query::new()
                    .intersect::&lt;Enemy&gt;(Access::Write)
                    .intersect::&lt;Transform&gt;(Access::Read),
            )
            .build();

        // Attach Enemy Bullet to Player Collision Function to the Engine schedule
        sched
            .add_system(Self::enemy_bullet_to_player_collision)
            .query(
                &quot;Enemy_Bullet&quot;,
                Query::new()
                    .intersect::&lt;Transform&gt;(Access::Read)
                    .intersect::&lt;Bullet&gt;(Access::Write),
            )
            .query(
                &quot;Player&quot;,
                Query::new()
                    .intersect::&lt;Player&gt;(Access::Write)
                    .intersect::&lt;Transform&gt;(Access::Read),
            )
            .query(
                &quot;Player_Status_Update&quot;,
                Query::new().intersect::&lt;PlayerStatus&gt;(Access::Write),
            )
            .query(
                &quot;Enemy_Bullet_Count_Update&quot;,
                Query::new().intersect::&lt;Enemy&gt;(Access::Write),
            )
            .build();

        Self
    }
}

// Implement the function systems for the server
impl ServerState {
    fn spawn_player(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };
        for entity in query.iter(&quot;Player&quot;) {
            if !(query.read::&lt;PlayerStatus&gt;(entity).status) {
                let mut dead_time = query.read::&lt;PlayerStatus&gt;(entity).dead_time;
                if dead_time == 0.0 {
                    dead_time = frame_time.time;
                }
                if dead_time + PLAYER_SPAWN_TIME &lt; frame_time.time {
                    io.create_entity()
                        .add_component(
                            Transform::default()
                                .with_position(Vec3::new(0.0, -50.0, 0.0))
                                .with_rotation(Quat::from_euler(EulerRot::XYZ, PI / 2., 0., 0.)),
                        )
                        .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
                        .add_component(Player::default())
                        .add_component(Synchronized)
                        .build();
                    io.remove_entity(entity);
                    io.create_entity()
                        .add_component(PlayerStatus::default())
                        .build();
                }
                else {
                    query.modify::&lt;PlayerStatus&gt;(entity, |value| {
                        value.dead_time = dead_time;
                    })
                }
            }
        }
    }
    // The function that will spawn the enemy
    fn spawn_enemy(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };

        if (query.iter(&quot;Enemy_Count&quot;).count() as u32) &lt; ENEMY_COUNT {
            for entity in query.iter(&quot;Enemy_Status&quot;) {
                let mut dead_time = query.read::&lt;EnemyStatus&gt;(entity).0;

                if dead_time == 0.0 {
                    dead_time = frame_time.time;
                }

                if dead_time + ENEMY_SPAWN_TIME &lt; frame_time.time {
                    io.create_entity()
                        .add_component(
                            Transform::default()
                                .with_position(Vec3::new(0.0, 50.0, 0.0))
                                .with_rotation(Quat::from_euler(EulerRot::XYZ, PI / 2., 0., 0.)),
                        )
                        .add_component(Render::new(ENEMY_HANDLE).primitive(Primitive::Lines))
                        .add_component(Synchronized)
                        .add_component(Enemy::default())
                        .build();
                    io.remove_entity(entity);
                    io.create_entity().add_component(EnemyStatus(0.0)).build();
                }
                else {
                    query.modify::&lt;EnemyStatus&gt;(entity, |value| {
                        value.0 = dead_time;
                    })
                }
            }
        }
    }
    // The function that will handle the player movement
    fn player_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for player_movement in io.inbox::&lt;MoveCommand&gt;() {
            for entity in query.iter(&quot;Player_Movement&quot;) {
                let x_limit = WITDH / 2.0;
                if query.read::&lt;Player&gt;(entity).current_position.x + player_movement.0.x
                    - PLAYER_SIZE
                    &lt; -x_limit
                    || query.read::&lt;Player&gt;(entity).current_position.x
                        + player_movement.0.x
                        + PLAYER_SIZE
                        &gt; x_limit
                {
                    return;
                }

                query.modify::&lt;Transform&gt;(entity, |transform| {
                    transform.pos += player_movement.0;
                });
                query.modify::&lt;Player&gt;(entity, |player| {
                    player.current_position += player_movement.0;
                });
            }
        }
    }

    // The function that will handle the enemy movement
    fn enemy_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity in query.iter(&quot;Enemy_Movement&quot;) {
            let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };
            let mut pcg_random_move = Pcg::new();
            let mut pcg_random_direction = Pcg::new();

            let x = if pcg_random_direction.gen_bool() {
                pcg_random_move.gen_f32() * 1.
            } else {
                pcg_random_move.gen_f32() * -1.
            };

            let y = if pcg_random_direction.gen_bool() {
                pcg_random_move.gen_f32() * 1.
            } else {
                pcg_random_move.gen_f32() * -1.
            };

            let speed = Vec3::new(x, y, 0.);

            let direction = speed.normalize() * frame_time.delta * ENEMY_SPEED;

            let x_limit = WITDH / 2.0;
            let y_upper_limit = HEIGHT / 2.;
            let y_limit = HEIGHT / 5.;

            let current_position = query.read::&lt;Enemy&gt;(entity).current_position;

            if (current_position.x + direction.x - ENEMY_SIZE &lt; -x_limit)
                || (current_position.x + direction.x + ENEMY_SIZE &gt; x_limit)
                || (current_position.y + direction.y &gt;= y_upper_limit)
                || (current_position.y + direction.y &lt; y_limit)
            {
                return;
            }
            query.modify::&lt;Transform&gt;(entity, |transform| {
                transform.pos += direction;
            });
            query.modify::&lt;Enemy&gt;(entity, |enemy| {
                enemy.current_position += direction;
            });
        }
    }

    // The function that will handle the player fire
    fn player_fire_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        if let Some(FireCommand(_value)) = io.inbox_first() {
            for entity in query.iter(&quot;Player_Fire_Input&quot;) {
                io.create_entity()
                    .add_component(
                        Render::new(PLAYER_BULLET_HANDLE).primitive(Primitive::Triangles),
                    )
                    .add_component(Synchronized)
                    .add_component(Bullet {
                        from_enemy: false,
                        from_player: true,
                        entity_id: entity,
                    })
                    .add_component(Transform::default().with_position(
                        query.read::&lt;Player&gt;(entity).current_position
                            + Vec3::new(-PLAYER_SIZE / 2., PLAYER_SIZE / 2., 0.0),
                    ))
                    .build();
                io.create_entity()
                    .add_component(
                        Render::new(PLAYER_BULLET_HANDLE).primitive(Primitive::Triangles),
                    )
                    .add_component(Synchronized)
                    .add_component(Bullet {
                        from_enemy: false,
                        from_player: true,
                        entity_id: entity,
                    })
                    .add_component(Transform::default().with_position(
                        query.read::&lt;Player&gt;(entity).current_position
                            + Vec3::new(PLAYER_SIZE / 2., PLAYER_SIZE / 2., 0.0),
                    ))
                    .build();
            }
        }
    }

    // The function that will handle the player bullet movement
    fn player_bullet_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() else { return };

        for entity in query.iter(&quot;Player_Bullet_Movement&quot;) {
            if query.read::&lt;Bullet&gt;(entity).from_player {
                if query.read::&lt;Transform&gt;(entity).pos.y &gt; HEIGHT / 2. - 2.5 {
                    io.remove_entity(entity);
                }
                query.modify::&lt;Transform&gt;(entity, |transform| {
                    transform.pos +=
                        Vec3::new(0.0, 1.0, 0.0) * frame_time.delta * PLAYER_BULLET_SPEED;
                });
            }
        }
    }

    // The function that will handle the enemy fire update
    fn enemy_fire_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        let mut pcg_fire = Pcg::new();

        for entity in query.iter(&quot;Enemy_Fire_Input&quot;) {
            if pcg_fire.gen_bool() {
                if query.read::&lt;Enemy&gt;(entity).bullet_count &lt; ENEMY_MAX_BULLET {
                    query.modify::&lt;Enemy&gt;(entity, |value| {
                        value.bullet_count += 1;
                    });
                    io.create_entity()
                        .add_component(
                            Render::new(ENEMY_BULLET_HANDLE).primitive(Primitive::Triangles),
                        )
                        .add_component(Synchronized)
                        .add_component(Bullet {
                            from_enemy: true,
                            from_player: false,
                            entity_id: entity,
                        })
                        .add_component(Transform::default().with_position(
                            query.read::&lt;Enemy&gt;(entity).current_position
                                + Vec3::new(0., -ENEMY_SIZE / 2., 0.),
                        ))
                        .build();
                }
            }
        }
    }

    // The function that will handle the enemy bullet movement
    fn enemy_bullet_movement_update(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        if let Some(frame_time) = io.inbox_first::&lt;FrameTime&gt;() {
            for entity in query.iter(&quot;Enemy_Bullet_Movement&quot;) {
                if query.read::&lt;Bullet&gt;(entity).from_enemy {
                    if query.read::&lt;Transform&gt;(entity).pos.y &lt; -HEIGHT / 2. + 2.5 {
                        if query
                            .iter(&quot;Enemy_Bullet_Count_Update&quot;)
                            .any(|id| id == query.read::&lt;Bullet&gt;(entity).entity_id)
                        {
                            query.modify::&lt;Enemy&gt;(
                                query.read::&lt;Bullet&gt;(entity).entity_id,
                                |value| {
                                    value.bullet_count -= 1;
                                },
                            );
                        }
                        io.remove_entity(entity);
                    }
                    query.modify::&lt;Transform&gt;(entity, |transform| {
                        transform.pos +=
                            Vec3::new(0.0, -1.0, 0.0) * frame_time.delta * ENEMY_BULLET_SPEED;
                    });
                }
            }
        }
    }

    // The function that will handle the collision from player bullet to enemy
    fn player_bullet_to_enemy_collision(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity1 in query.iter(&quot;Player_Bullet&quot;) {
            if query.read::&lt;Bullet&gt;(entity1).from_player {
                for entity2 in query.iter(&quot;Enemy&quot;) {
                    let current_player_bullet = query.read::&lt;Transform&gt;(entity1).pos;
                    let current_enemy = query.read::&lt;Transform&gt;(entity2).pos;

                    if collision_detection(
                        current_player_bullet.x,
                        current_player_bullet.y,
                        BULLET_SIZE,
                        current_enemy.x,
                        current_enemy.y,
                        ENEMY_SIZE,
                    ) {
                        io.remove_entity(entity1);
                        io.remove_entity(entity2);
                    }
                }
            }
        }
    }

    // The function that will handle the collision from enemy bullet to player
    fn enemy_bullet_to_player_collision(&amp;mut self, io: &amp;mut EngineIo, query: &amp;mut QueryResult) {
        for entity1 in query.iter(&quot;Enemy_Bullet&quot;) {
            if query.read::&lt;Bullet&gt;(entity1).from_enemy {
                for entity2 in query.iter(&quot;Player&quot;) {
                    let current_enemy_bullet = query.read::&lt;Transform&gt;(entity1).pos;
                    let current_player = query.read::&lt;Transform&gt;(entity2).pos;

                    if collision_detection(
                        current_enemy_bullet.x,
                        current_enemy_bullet.y,
                        BULLET_SIZE,
                        current_player.x,
                        current_player.y,
                        PLAYER_SIZE,
                    ) {
                        if query
                            .iter(&quot;Enemy_Bullet_Count_Update&quot;)
                            .any(|id| id == query.read::&lt;Bullet&gt;(entity1).entity_id)
                        {
                            query.modify::&lt;Enemy&gt;(
                                query.read::&lt;Bullet&gt;(entity1).entity_id,
                                |value| {
                                    value.bullet_count -= 1;
                                },
                            );
                        }
                        io.remove_entity(entity1);
                        io.remove_entity(entity2);
                        for entity3 in query.iter(&quot;Player_Status_Update&quot;) {
                            query.modify::&lt;PlayerStatus&gt;(entity3, |value| {
                                value.status = false;
                            });
                        }
                    }
                }
            }
        }
    }
}

// The function that will handle the collision detection
fn collision_detection(
    obj1_x_position: f32,
    obj1_y_position: f32,
    obj1_size: f32,
    obj2_x_position: f32,
    obj2_y_position: f32,
    obj2_size: f32,
) -&gt; bool {
    if obj1_x_position - (obj1_size / 2.) &lt;= obj2_x_position + (obj2_size / 2.)
        &amp;&amp; obj1_x_position + (obj1_size / 2.) &gt;= obj2_x_position - (obj2_size / 2.)
        &amp;&amp; (obj1_y_position - (obj1_size / 2.) &lt;= obj2_y_position + (obj2_size / 2.))
        &amp;&amp; (obj1_y_position + (obj1_size / 2.) &gt;= obj2_y_position - (obj2_size / 2.))
    {
        return true;
    }
    return false;
}

// Defines entry points for the engine to hook into.
// Calls new() for the appropriate state.
make_app_state!(ClientState, ServerState);

<span class="boring">}</span></code></pre></pre>
<h2 id="what-is-next"><a class="header" href="#what-is-next">What is next?</a></h2>
<p>So you might be wondering... since this is the last page of the tutorial, are we done with the program? Yes and No. Yes, because we tackle all the basic syntax and concept of the engine that you need to create your own plugin. However, there is no text display or sound implementation. These features will be added into the plugin tutorial later on, when these components are implemented into the engine. Please keep posted for additional tutorials for this plugin. If you want to check out the most up to date code for galaga, you can check out <a href="https://github.com/ChatImproVR/galaga"><strong>HERE</strong></a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="engine-development"><a class="header" href="#engine-development">Engine development</a></h1>
<p>The current implementation of ChatImproVR's engine is <code>chatimprovr</code>. It's assumed that you've read the previous sections, and understand how to write plugins for ChatImproVR.</p>
<p>ChatImproVR is split into a few different parts. The <strong>Engine</strong> is the core of a ChatImproVR <strong>Host</strong>. It is responsible for managing the ECS, facilitating pub/sub messaging, and loading plugin code. The engine contains no code responsible for interacting with the outside world; it has no networking cabablity nor does it render scenes or take user input. That is the responsibility of the rest of the <strong>Host</strong>'s code. </p>
<p>The <strong>Client</strong> contains a number of subsystems which allow the <strong>Engine</strong> to interact with the user:</p>
<ul>
<li><code>desktop</code>: All interfacing with desktop platforms; keyboard and mouse input. Contains the desktop mainloop</li>
<li><code>vr</code>: All interfacing with virtual reality platforms; controller and headset motion. Contains the VR mainloop</li>
<li><code>ui</code>: Simple GUI for use from within plugins</li>
<li><code>render</code>: Putting meshes on the screen, assigning shaders, etc.</li>
</ul>
<p>Each of these subsystems interacts with the <strong>Engine</strong> by making ECS queries and checking the message <strong>Inboxes</strong> that they've subscribed to. In this way, creating subsystems is very much like writing plugins.</p>
<p>The <strong>Server</strong> is a lot simpler, except that it may connect to many <strong>Clients</strong> and is intended to be a headless program. It has a few simple subsystems which e.g. report which clients are connected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-fixes"><a class="header" href="#common-fixes">Common fixes</a></h1>
<h2 id="cannot-find-function-_print_str-in-this-scope"><a class="header" href="#cannot-find-function-_print_str-in-this-scope">cannot find function <code>_print_str</code> in this scope</a></h2>
<pre><code>error[E0425]: cannot find function `_print_str` in this scope
  --&gt; src/obj.rs:31:17
   |
31 |                 dbg!(pos, uvw);
   |                 ^^^^^^^^^^^^^^ not found in this scope
   |
   = note: this error originates in the macro `$crate::println` which comes from the expansion of the macro `dbg` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
   |
1  | use cimvr_engine_interface::prelude::_print_str;
   |
1  | use crate::_print_str;
   |
</code></pre>
<h3 id="the-fix"><a class="header" href="#the-fix">The fix:</a></h3>
<p>Just add the prelude from the engine interface:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cimvr_engine_interface::prelude::*;
<span class="boring">}</span></code></pre></pre>
<h2 id="windows-running-scripts-disabled"><a class="header" href="#windows-running-scripts-disabled">Windows: Running scripts disabled</a></h2>
<p>If you are on Windows and are trying to run the <code>cimvr</code> script, there is a chance you might run into this issue:</p>
<pre><code>..\WindowsPowerShell\Microsoft.Powershell_profile.ps1 cannot be loaded because running scripts is disabled on this system.
</code></pre>
<h3 id="the-fix-1"><a class="header" href="#the-fix-1">The fix:</a></h3>
<ol>
<li>Open Windows PowerShell and run as administrator. </li>
<li>Run <code>Get-ExecutionPolicy</code> to get the current execution policy applied, such as &quot;Restricted&quot;.</li>
<li>Run <code>Set-ExecutionPolicy RemoteSigned</code> and press <code>Y</code> when prompted. </li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
