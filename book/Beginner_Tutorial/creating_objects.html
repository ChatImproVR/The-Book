<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Creating Objects - The Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Installation</div></li><li class="chapter-item expanded "><a href="../dev_env.html"><strong aria-hidden="true">3.</strong> Development Environment</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/core_concepts.html"><strong aria-hidden="true">4.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Core_Concepts/plugin.html"><strong aria-hidden="true">4.1.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/wasm.html"><strong aria-hidden="true">4.2.</strong> Webassembly</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/entity_component_system.html"><strong aria-hidden="true">4.3.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/pub_sub.html"><strong aria-hidden="true">4.4.</strong> Pub/Sub channels</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/client_and_server.html"><strong aria-hidden="true">4.5.</strong> Client and Server</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/crates.html"><strong aria-hidden="true">4.6.</strong> Crates</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/names.html"><strong aria-hidden="true">4.7.</strong> Names</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/coordinate_system.html"><strong aria-hidden="true">4.8.</strong> Coordinate system</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/rendering.html"><strong aria-hidden="true">4.9.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="../Core_Concepts/api_docs.html"><strong aria-hidden="true">4.10.</strong> API documentation</a></li></ol></li><li class="chapter-item expanded "><a href="../Beginner_Tutorial/beginner_plugin_development_tutorial.html"><strong aria-hidden="true">5.</strong> Beginner Plugin Development Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Beginner_Tutorial/setting_up_plugin_development_environment.html"><strong aria-hidden="true">5.1.</strong> Setting up Plugin Development Environment</a></li><li class="chapter-item expanded "><a href="../Beginner_Tutorial/understanding_the_plugin_template.html"><strong aria-hidden="true">5.2.</strong> Understanding the Plugin Template</a></li><li class="chapter-item expanded "><a href="../Beginner_Tutorial/creating_objects.html" class="active"><strong aria-hidden="true">5.3.</strong> Creating Objects</a></li><li class="chapter-item expanded "><a href="../Beginner_Tutorial/adding_object_behaviors.html"><strong aria-hidden="true">5.4.</strong> Adding Object Behaviors</a></li><li class="chapter-item expanded "><a href="../Beginner_Tutorial/configuring_game_settings.html"><strong aria-hidden="true">5.5.</strong> Configuring Game Settings</a></li></ol></li><li class="chapter-item expanded "><a href="../for_engine_developers.html"><strong aria-hidden="true">6.</strong> For Engine developers</a></li><li class="chapter-item expanded "><a href="../quality_of_life.html"><strong aria-hidden="true">7.</strong> Quality Of Life</a></li><li class="chapter-item expanded "><a href="../common_fixes.html"><strong aria-hidden="true">8.</strong> Common fixes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="creating-objects"><a class="header" href="#creating-objects">Creating Objects</a></h1>
<p>Now we have our template of the plugin and have some knowledge on what is going on, let's start working on object creation. Without any objects in the environment, we cannot do anything with it.</p>
<h2 id="review"><a class="header" href="#review">Review</a></h2>
<p>Before we start adding code into the plugin, let's review what is an ECS. Please refer to this <a href="../Core_Concepts/entity_component_system.html">page</a>.</p>
<p>In short, we need to have ID for each object that is associated with each graphic itself.</p>
<h2 id="adding-packageslibrariescrates"><a class="header" href="#adding-packageslibrariescrates">Adding packages/libraries/crates</a></h2>
<p>Insert the following packages/libraries/crates (We will call them crates for now on) into the very top of <code>lib.rs</code> file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cimvr_engine_interface::{make_app_state, prelude::*, pkg_namespace};

use cimvr_common::{
    glam::{EulerRot, Quat, Vec3},
    render::{Mesh, MeshHandle, Primitive, Render, UploadMesh, Vertex},
    Transform,
};
<span class="boring">}</span></code></pre></pre>
<p>Some of the crates are familiar from the plugin template such as <code>make_app_state</code> or <code>prelude::*</code>. Here is a brief summary on the remaining crates.</p>
<ul>
<li><code>pkg_namespace</code>: This allows us to easily and uniquely name component and message data types based on our crate's (plugin's) name.</li>
<li><code>cimvr_common</code>: The main crate that handles communcation between server and client.
<ul>
<li><code>render</code>: The main crate for object loading part (the main itself explains that it will render graphics)
<ul>
<li><code>Mesh</code>: This will contain both vertices and indices: <strong>This will be important later on the object creation part</strong>.</li>
<li><code>MeshHandle</code>: This handle refers to a mesh without containing its data</li>
<li><code>Primitive</code>: This will describe the method of rendering the object: <strong>This is important when it comes to object creation</strong>.</li>
<li><code>Render</code>: This component is the most important for rendering; it tells the rendering engine how to render the given <code>MeshHandle</code>.</li>
<li><code>UploadMesh</code>: This will send the mesh to the client.</li>
<li><code>Vertex</code>: It contains the coordinates and rgb value and/or texture coordinates for a given vertex.</li>
</ul>
</li>
<li><code>Transform</code>: The will set the position and orientation of the object.</li>
</ul>
</li>
</ul>
<h2 id="create-id-for-each-object"><a class="header" href="#create-id-for-each-object">Create ID For Each Object</a></h2>
<p>First, we need to declare the <code>MeshHandle</code> to assign each ID for each object. In the game of galaga, we need to assign four parts: player, enemy, player's bullet, and enemy's bullet.</p>
<p>We can set up the ID value like the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PLAYER_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player&quot;));
const ENEMY_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy&quot;));
const PLAYER_BULLET_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player Bullet&quot;));
const ENEMY_BULLET_HANDLE : MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy Bullet&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Each line represents the ID for each entity/object. We will declare a constant value that it is a MeshHandle with the name holder of the object using the <code>pkg_namespace</code>. 
These variables should not be declare in ServerState nor ClientState.</p>
<h2 id="setting-up-the-mesh-for-each-object"><a class="header" href="#setting-up-the-mesh-for-each-object">Setting up the Mesh for Each Object</a></h2>
<p>Now we have declare the MeshHandle, we need to create the Mesh itself, or the object itself.</p>
<p>If you want to use <code>Blender</code> to create an object and upload that as a mesh into the plugin, please refer the <a href="/Beginner_Tutorial/creating_objects.html#blender">Blender</a> section that is below this section.</p>
<p>Let's start making the player object itself. Our design, since it is a basic model, will be a sqaure for the player.
First, we declare a function that returns a Mesh type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player() -&gt; Mesh {}
<span class="boring">}</span></code></pre></pre>
<p>Inside the function, we need to define how big we want to be.
For now, let's define the size variable inside the player function as 5.0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player() -&gt; Mesh {
    let size = 5.0;
}
<span class="boring">}</span></code></pre></pre>
<p>Inside a Mesh, there is vertices and indices that we need to define and return.
Let's take a look at the Vertex data type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vertex {
    /// Local position
    pub pos: [f32; 3],
    /// Either u, v, w for textures or r, g, b for colors
    pub uvw: [f32; 3],
}
<span class="boring">}</span></code></pre></pre>
<p>From this point, we will deviate into two sections: 2D and 3D. First we will cover the 2D section. If you want to get information regarding 3D, please refer to <a href="/Beginner_Tutorial/creating_objects.html#3d">this section</a>, but we highly recommend to read the 2D section first.</p>
<h3 id="2d"><a class="header" href="#2d">2D</a></h3>
<p>As you see above, the Vertex takes [x,y,z] position and [r,g,b] color combination.
The word vertex means a point. We are poviding the point value of the object. Because we decided to make the player as a sqaure rather than fancy object looking, it can define as the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 0
        Vertex::new([size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 1
        Vertex::new([size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 2
        Vertex::new([-size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 3
    ];
<span class="boring">}</span></code></pre></pre>
<p>The variable vertices is vector that contains several vertext of the object itself.
Inside the first Vertex variable, the first array is define as the position of the vertex location whereas the second array is the rgb value. Since we define the value <code>size</code> previously, we can use the value in the x and y value. We are not creating a 3D galaga game, which there is no need to insert a z value. Therefore, the z value is <code>0.0</code> rather than some other numerical value.</p>
<p>For the rgb value, we are using the scale between 0.0 to 1.0 rather than the traditional of 0 to 255. If you want to get the exact value of the rgb value based on the scale between 0 to 255, you can simply do the value desire over 255. For example, if you want to have a certain red value (like 200), the math will be 200/255 which results to 0.7843137255. In this case, we are setting the player object as blue.</p>
<p>Now let's switch our focus to the indices. We need to place the vertex by following the <strong>Right Hand Rule</strong>. For people who do not know what is the Right Hand Rule, it can be explain the image below.</p>
<p><img src="./right_hand_rule.jpeg" alt="Right Hand Rule In Image" /></p>
<p>Let's say the green arrow represents the x-axis, the blue arrow represents the y-axis, and the red arrow represents the z-axis. If we place the vertex in the counter clockwise order for both x and y values, then the z value will be positive that will be facing us. If we place the order of the vertex in the opposite order/ clockwise, then it will face down. Since we want to place the object facing toward us, we need to place the vertices in the counter clockwise order.</p>
<p>Therefore, the indices variable will be define as below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let indices: Vec&lt;u32&gt; = vec![0,1,2,2,3,0];
<span class="boring">}</span></code></pre></pre>
<p>The 0, 1, 2, 3 came from the Vertex 0, Vertex 1, Vertex 2, and Vertex 3 that is describe above. Vertex 0 is the bottom left corner; Vertex 1 is the bottom right corner; Vertex 2 is upper right corner; and Vertex 3 is the upper left corner of the square.</p>
<p>Here is an example drawing on how it will be displayed.</p>
<p><img src="./vertex_image_rotation.jpg" alt="Player_Object_Drawing_Method_In_Image" /></p>
<p>Lastly, we need to return the value of Mesh type as the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Mesh {vertices, indices}
<span class="boring">}</span></code></pre></pre>
<p>Therefore the complete version of the player mesh function will be define as following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player() -&gt; Mesh {
    let size: f32 = 5.0;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 0
        Vertex::new([size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 1
        Vertex::new([size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 2
        Vertex::new([-size, size, 0.0], [0.0, 0.0, 1.0]), // Vertex 3
    ];

    let indices: Vec&lt;u32&gt; = vec![0,1,2,2,3,0];

    Mesh {vertices, indices}
}
<span class="boring">}</span></code></pre></pre>
<p>For each object, we need to the followng for the remaining enemy. enemy's bullet, and player's bullet. If you want to learn more depth regarding drawing objects, here is a <a href="https://learnopengl.com/Getting-started/Hello-Triangle">great resource</a> to refer.</p>
<h3 id="3d"><a class="header" href="#3d">3D</a></h3>
<p>With the same approach as creating 2D objects, we need to increase more vertex and identify which indices will connect to which indices. The following code will make a cube instead of a sqaure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Defines the mesh data fro a cube
fn cube() -&gt; Mesh {
    // Size of the cube mesh
    let size = 0.25;

    // List of vertex positions and colors
    let vertices = vec![
        Vertex::new([-size, -size, -size], [0.0, 1.0, 1.0]),
        Vertex::new([size, -size, -size], [1.0, 0.0, 1.0]),
        Vertex::new([size, size, -size], [1.0, 1.0, 0.0]),
        Vertex::new([-size, size, -size], [0.0, 1.0, 1.0]),
        Vertex::new([-size, -size, size], [1.0, 0.0, 1.0]),
        Vertex::new([size, -size, size], [1.0, 1.0, 0.0]),
        Vertex::new([size, size, size], [0.0, 1.0, 1.0]),
        Vertex::new([-size, size, size], [1.0, 0.0, 1.0]),
    ];

    // Each 3 indices (indexing into vertices) define a triangle
    let indices = vec![
        3, 1, 0, 2, 1, 3, 2, 5, 1, 6, 5, 2, 6, 4, 5, 7, 4, 6, 7, 0, 4, 3, 0, 7, 7, 2, 3, 6, 2, 7,
        0, 5, 4, 1, 5, 0,
    ];

    Mesh { vertices, indices }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sending-the-mesh-from-client-to-server"><a class="header" href="#sending-the-mesh-from-client-to-server">Sending the Mesh from Client to Server</a></h2>
<p>Once we have generated the Mesh for each object with the correct Render ID, we need to send that Mesh with the correct ID to the server. Inside the new function below, we need to insert the following command.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send(&amp;UploadMesh{
    id: PLAYER_HANDLE,
    mesh: player(),
});

<span class="boring">}</span></code></pre></pre>
<p>Let's take a deep look into this command itself.</p>
<p>The command will send to the EngineIo as a <code>UploadMesh</code> struct that contains the Render ID and the mesh itself. We know both of the id (<code>PLAYER_HANDLE</code>) and the mesh (<code>player()</code>). </p>
<p>That is all for sending mesh from the client to the server. Pretty easy. The complete code will be looking similar below. This implementation is inside the <code>ClientState</code> <code>new</code> function. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        io.send(&amp;UploadMesh{
            id: PLAYER_HANDLE,
            mesh: player(),
        });

        Self
}
<span class="boring">}</span></code></pre></pre>
<p>You do the same process for all the remaining objects such as the enemy, enemy_bullets, and the player_bullets.</p>
<h2 id="blender"><a class="header" href="#blender">Blender</a></h2>
<p>While using Mesh is great by declearing a type and modify from there, it is very limited to the extend of creating more unique objects. Therefore, we have a different method to implement mesh into the plugin using <code>Blender</code>!</p>
<p>The object loader is already part of CimVR that we just need to update the <code>Cargo.toml</code> file. Inside the <code>Cargo.toml</code> file of your plugin, add a new line under dependencies.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>obj_reader = {path = &quot;../chatimprovr/obj_loader&quot;} // The path might look different 
<span class="boring">}</span></code></pre></pre>
<p>You can declare whatever you want, but make sure the path is located in the right file that will read the file. </p>
<p>Once that is complete, you need to use that crate to load the function <code>obj_lines_to_mesh</code>.</p>
<p>At the beginning of the <code>lib.rs</code> file where you declare crates, add the following line.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add libraries from the obj_reader crate
use obj_reader::obj::obj_lines_to_mesh;
// If you name the dependency differently, then change the name accordingly
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-between-blender-and-chatimprovr"><a class="header" href="#differences-between-blender-and-chatimprovr">Differences between Blender and ChatImproVR</a></h2>
<p>The biggest differences between Blender and ChatImproVR is axes are different. Take a look at the following image below.</p>
<p><img src="./xyz_reference.png" alt="XYZ_Reference" /></p>
<p>The color lines represent axes in ChatImproVR whereas the solid white lines with the labels for each axes represent the axes in Blender.
For people who are not familiar with the color line axes representation, here is a summary about it.</p>
<ul>
<li>Red Line represents the <strong>X-axis</strong></li>
<li>Green Line represents the <strong>Y-axis</strong></li>
<li>Blue Line represents the <strong>Z-axis</strong></li>
<li>The Solid Lines represent <strong>positive</strong> direction</li>
<li>The Dotted Lines represent <strong>negative</strong> direction</li>
</ul>
<p>As you see, the blender axes does not match with the ChatImproVR axes; for example, the Y-axis for blender is on the Z-axis for ChatImproVR. Therefore, we need to make sure to export the object correctly so that we do not need to modify the object viewing inside the code (In this tutorial, we had to modify to show other features; hence, we highly recommed to follow this section.)</p>
<p>For the biggest difference is that the <strong>negative Y-axis</strong> in <strong>Blender</strong> is <strong>positive Z-axis</strong> in <strong>ChatImproVR</strong> whereas <strong>positive Z-axis</strong> in <strong>Blender</strong> is <strong>positive Y-axis</strong> in <strong>ChatImproVR</strong>.</p>
<h2 id="how-to-create-an-object-in-blender-and-export-correctly"><a class="header" href="#how-to-create-an-object-in-blender-and-export-correctly">How to Create an Object in Blender and Export Correctly</a></h2>
<p>Now we know what is the major differences, how do we export the object correctly using blender? First, we need to create an object in Blender. There are many tutorials on how to make an object of whatever design you prefer. Once the object has been created in Blender, follow the next steps.</p>
<ol>
<li>In <strong>File</strong>, select <strong>Export</strong>, then select <strong>Wavefront</strong> like the image below. It should have the file type as <strong>(.obj)</strong></li>
</ol>
<p><img src="./Blender_Export_Step_1.png" alt="Step 1" /></p>
<ol start="2">
<li>
<p>Match the option as the image below.
<img src="./blender_export_option.png" alt="Step 2" /></p>
</li>
<li>
<p>Once that settings is correct, then select export to your desired location with the desired object file name. In our case, we are going to save it in <code>src/assets</code>.</p>
</li>
</ol>
<h2 id="how-to-send-an-object-from-blender-from-client-to-server"><a class="header" href="#how-to-send-an-object-from-blender-from-client-to-server">How to send an Object from Blender from Client to Server</a></h2>
<p>The process of sending a object mesh from Blender from client to server is very similar like how you send a mesh that is created inside the plugin. Inside the <code>new</code> function, insert the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.send(&amp;UploadMesh {
            id: ENEMY_HANDLE,
            mesh: obj_lines_to_mesh(include_str!(&quot;assets/circle.obj&quot;)),
        });
<span class="boring">}</span></code></pre></pre>
<p>The only difference between the previous method and this method is the <code>mesh</code> component: instead of custom created mesh, we are using the <code>obj_lines_to_mesh</code> function to load the mesh. In the example above, by inserting the <code>obj_lines_to_mesh</code> function with the argument of the path of object file (in this case will be the <code>circle.obj</code> file), it will load properlly.</p>
<p>Once that is complete, then we have sent the Render ID and mesh to the server. For this plugin, we will using the player and enemies as of now. We will add more objects mesh as we continue the tutorial.</p>
<h2 id="how-to-display-the-object-from-the-server"><a class="header" href="#how-to-display-the-object-from-the-server">How to display the Object from the Server</a></h2>
<p>Based on the client side code, we are just sending the Render ID to the server, not the mesh data itself. Therefore, in order to render the entity we want to display, we need to call the Render ID while we are creating the entity.</p>
<h2 id="so-how-do-you-create-an-entity"><a class="header" href="#so-how-do-you-create-an-entity">So, how do you create an entity?</a></h2>
<p>In the <code>ServerState</code> implementation, we will add the following commands inside the <code>new</code> function for creating the player entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Player entity with components
        io.create_entity()
            // Add the render component to draw the player with lines
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Add the transform component for movement
            .add_component(Transform::default())
            // Build the entity
            .build();
<span class="boring">}</span></code></pre></pre>
<p>We can split into (technically two) three functions when creating the entity using <code>io</code>. The first line <code>.create_entity()</code> tells the server that we are creating an entity. The second to fourth line that contains the function <code>.add_component</code> is the method of adding component as name states. In layman terms, we are adding characteristics to the entity. The last line that contains the <code>.build();</code> tells the server that we are done adding component to this entity and build it.</p>
<p>The most important function when creating is <code>.add_component()</code> function call. In the code/example above, there are three unique calls, which will cover each part in depth.</p>
<h3 id="render"><a class="header" href="#render">Render</a></h3>
<p>When you add this component to a certain entity, it indicates that we are giving an render data to this entity that could appear on the client side. This is where we use the Render ID to render the entity that was sent from the client side. In the given example, we are going to render this entity as a player by providing the <code>PLAYER_HANDLE</code> Render ID to the entity. This explains up to the part of <code>.add_component(Render::new(PLAYER_HANDLE))</code>.</p>
<p>The <code>.primitive(Primitive::Lines)</code> part explains what method are we going to render. There are three methods to render the entity: <code>Lines</code>, <code>Points</code>, or <code>Triangles</code>. The name itself explains how it will be render except <code>Triangles</code>. The <code>Triangles</code> method use the idea of the right hand rule that by providing the three vertices to format as a triangle will fill out the area with the given color. In this case, because the player ship is created over blender with only lines, the example says Lines, but if you want to render in a different method, you are welcome to do so.</p>
<h3 id="synchronized"><a class="header" href="#synchronized">Synchronized</a></h3>
<p>When you add this component to a certain entity, it indicates that whatever happens to the server will also update on the client side as well. We want to have this component; for example, if the player is hit from the enemy's bullet, then the player must be deleted, but if we do not have this component, the client will never know when it should be deleted or not.</p>
<p>If the client do not care regarding updates from the server side, then you do not need to add this component. Otherwise, must add this component.</p>
<h3 id="transform"><a class="header" href="#transform">Transform</a></h3>
<p>When you add this component to a certain entity, it indicates that this entity will be display on the client side whether or not it has a mesh data. This component seems somewhat redundent and useless at first because the entity will be display even without any render data; in other words, why would call this component if you do not need to render something. However, the transform allows you to do a lot of customization when it comes to positioning and rotation, which will cover in the next section.</p>
<h2 id="customizing-the-render-settings"><a class="header" href="#customizing-the-render-settings">Customizing the render settings</a></h2>
<p>Take a good look at the following example code below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Player entity with components
        io.create_entity()
            // Add the transform component for movement
            .add_component(
                // Add the default transform component
                Transform::default()
                    // Set the bottom middle of the screen as the initial position
                    .with_position(Vec3::new(0.0, -50.0, 0.0))
                    // Set the initial rotation to be facing towards to the player based on the camera angle (no needed if you create the object facing a different direction)
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, PI/2., 0., 0.)),
            )
            // Add the render component to draw the player with lines
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();
<span class="boring">}</span></code></pre></pre>
<p>There are two things you have noticed:</p>
<ol>
<li>The order of adding the component is different than the previous example. This tells that adding the component order does not matter what so ever. </li>
<li>There are more functions from the <code>Transform</code> component.</li>
</ol>
<p>Within each call for adding new components, you can set even more options in depth of the entity. In this example, we want to set the component location below the screen, where the player should be located. Therefore, we add te <code>.with_position()</code> function call with a <code>Vec3</code> input value of the position. Since it should be display in the bottom middle screen, the position will be <code>Vec3(0.,-50.,0.)</code>.</p>
<p>Because the object is created by Blender with the <code>xyz</code> reference is relative rather than objective, there is a need to rotate the object based on the X-axis by 90 degrees in radines (which it is PI/2). Therefore, we also need to call <code>.with_roation()</code> with the value of <code>Quat::from_euler(EulorRot::XYZ,PI/2.,0.,0.)</code>. At the same time, we need to add the PI value from the standard libary. Therefore, add the <code>use std::{f32::consts::PI};</code> in the beginning of the file.</p>
<p>We will create entities for enemy as well: NOT THE BULLET.</p>
<h2 id="wait-what-about-the-bullets"><a class="header" href="#wait-what-about-the-bullets">Wait...? What about the bullets?</a></h2>
<p>In the new function inside the ServerState, we have generated the entities for Player and Enemy, but not the bullets. Why?</p>
<p>The new function will generate the entity when the program starts. In other words, when the program starts, the entity (if we add the componenet to display) will display at the beginning, which it is not the case for bullets. We want to create and remove the bullets when the player press a certain button to shoot the bullet or the enemy decides to shoot the bullet. </p>
<p>Therefore, we are going to generate the bullet based on certain function input. We will go in depth about it, but we can simply ignore the bullet at this point.</p>
<h2 id="configuring-the-camera-angle"><a class="header" href="#configuring-the-camera-angle">Configuring the Camera Angle</a></h2>
<p>Inside the engine's example plugins, there are several plugins that you can refer to. One of the example plugin that we are using is <code>camera2d</code> plugin. This plugin will automatically set the camera angle as a 2D angle. Therefore, if you want to see the current progress, all you need to do (after compiling the galaga code) is entering the following.</p>
<p><code>cimvr galaga camera2d</code> or <code>cimvr camera2d galaga</code>. The order does not matter when it comes to calling the plugin.</p>
<p>If you want to customize the camera in your own angle, please refer the documentation in the camera utility.</p>
<h2 id="summarycurrent-code-progress"><a class="header" href="#summarycurrent-code-progress">Summary/Current Code Progress</a></h2>
<p>The following code should be similar to the code that is provided.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{f32::consts::PI};

// Add libraries from the cimvr_engine_interface crate
use cimvr_engine_interface::{make_app_state, pkg_namespace, prelude::*};

// Add libraries from the cimvr_common crate
use cimvr_common::{
    glam::{EulerRot, Quat, Vec3},
    render::{Mesh, MeshHandle, Primitive, Render, UploadMesh, Vertex},
    Transform,
};

// Add libraries from the obj_reader crate
use obj_reader::obj::obj_lines_to_mesh;

// Create some constant value for Windows
const WITDH: f32 = 80.;
const HEIGHT: f32 = 120.;

// Create some constant values for Enemy
const ENEMY_SIZE: f32 = 3.; 

// Create some constant values for Player
const PLAYER_SIZE: f32 = 3.; // Because of the obj file, this value is not used (update this value after changing the obj size)

// Create some constant values for Bullet
const BULLET_SIZE: f32 = 0.5;


// Create mesh handleer based on each object's name
const PLAYER_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player&quot;));
const ENEMY_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy&quot;));
const PLAYER_BULLET_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Player Bullet&quot;));
const ENEMY_BULLET_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Enemy Bullet&quot;));
const WINDOW_SIZE_HANDLE: MeshHandle = MeshHandle::new(pkg_namespace!(&quot;Window Size&quot;));

// Create Meshes for each object

// Create the Player Mesh --&gt; This is commented out because we are using obj file
// fn player() -&gt; Mesh {
//     let size: f32 = PLAYER_SIZE;

//     let vertices = vec![
//         Vertex::new([-size, -size, 0.0], [0.0, 0.0, 1.0]), // Vertex 0
//         Vertex::new([size, -size, 0.0], [0.0, 0.0, 1.0]),  // Vertex 1
//         Vertex::new([size, size, 0.0], [0.0, 0.0, 1.0]),   // Vertex 2
//         Vertex::new([-size, size, 0.0], [0.0, 0.0, 1.0]),  // Vertex 3
//     ];

//     let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

//     Mesh { vertices, indices }
// }

// // Create the Enemy Mesh --&gt; This is commented out because we are using obj file
// fn enemy() -&gt; Mesh {
//     let size: f32 = ENEMY_SIZE;

//     let vertices = vec![
//         Vertex::new([-size, -size, 0.0], [1.0, 0.0, 0.0]), // Vertex 0
//         Vertex::new([size, -size, 0.0], [1.0, 0.0, 0.0]),  // Vertex 1
//         Vertex::new([size, size, 0.0], [1.0, 0.0, 0.0]),   // Vertex 2
//         Vertex::new([-size, size, 0.0], [1.0, 0.0, 0.0]),  // Vertex 3
//     ];

//     let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

//     Mesh { vertices, indices }
// }

// Create Player Bullet Mesh as a sqaure green
fn player_bullet() -&gt; Mesh {
    let size: f32 = BULLET_SIZE;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([size, -size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([size, size, 0.0], [0.0, 1.0, 0.0]),
        Vertex::new([-size, size, 0.0], [0.0, 1.0, 0.0]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

    Mesh { vertices, indices }
}

// Create Enemy Bullet Mesh as a sqaure red
fn enemy_bullet() -&gt; Mesh {
    let size: f32 = BULLET_SIZE;

    let vertices = vec![
        Vertex::new([-size, -size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([size, -size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([size, size, 0.0], [1.0, 0.0, 0.0]),
        Vertex::new([-size, size, 0.0], [1.0, 0.0, 0.0]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 2, 1, 2, 0];

    Mesh { vertices, indices }
}

// Create Window Mesh so that the users will know what is the limit of movement
fn window_size() -&gt; Mesh {
    let vertices = vec![
        Vertex::new([-WITDH / 2., -HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([WITDH / 2., -HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([WITDH / 2., HEIGHT / 2., 0.0], [1.; 3]),
        Vertex::new([-WITDH / 2., HEIGHT / 2., 0.0], [1.; 3]),
    ];

    let indices: Vec&lt;u32&gt; = vec![3, 0, 0, 1, 1, 2, 2, 3];

    Mesh { vertices, indices }
}

#[derive(Default)]
struct ClientState;

impl UserState for ClientState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {
        // Declare the player color as green
        let player_color = [0., 1., 0.];

        // Read the player object file from the assets folder (that is created from blender)
        let mut new_player_mesh = obj_lines_to_mesh(&amp;include_str!(&quot;assets/galagaship.obj&quot;));

        // Update the player object/mesh with the player color
        new_player_mesh
            .vertices
            .iter_mut()
            .for_each(|v| v.uvw = player_color);

        // Declare the enemy color as red
        let enemy_color = [1., 0., 0.];

        // Read the enemy object file from the assets folder (that is created from blender)
        let mut new_enemy_mesh = obj_lines_to_mesh(&amp;include_str!(&quot;assets/galaga_enemy.obj&quot;));

        // Update the enemy object/mesh with the enemy color
        new_enemy_mesh
            .vertices
            .iter_mut()
            .for_each(|v| v.uvw = enemy_color);

        // Send the player mesh and the player mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: PLAYER_HANDLE,
            mesh: new_player_mesh,
        });

        // Send the enemy mesh and the enemy mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: ENEMY_HANDLE,
            mesh: new_enemy_mesh,
        });

        // Send the player bullet mesh and the player bullet mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: PLAYER_BULLET_HANDLE,
            mesh: player_bullet(),
        });

        // Send the enemy bullet mesh and the enemy bullet mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: ENEMY_BULLET_HANDLE,
            mesh: enemy_bullet(),
        });

        // Send the window mesh and the window mesh handler to the server side
        io.send(&amp;UploadMesh {
            id: WINDOW_SIZE_HANDLE,
            mesh: window_size(),
        });

        Self::default()
    }
}

// All state associated with server-side behaviour
struct ServerState;

// Implement server only side functions that will update on the server side
impl UserState for ServerState {
    // Implement a constructor
    fn new(io: &amp;mut EngineIo, sched: &amp;mut EngineSchedule&lt;Self&gt;) -&gt; Self {

        // Create Player entity with components
        io.create_entity()
            // Add the transform component for movement
            .add_component(
                // Add the default transform component
                Transform::default()
                    // Set the bottom middle of the screen as the initial position
                    .with_position(Vec3::new(0.0, -50.0, 0.0))
                    // Set the initial rotation to be facing towards to the player based on the camera angle (no needed if you create the object facing a different direction)
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, PI/2., 0., 0.)),
            )
            // Add the render component to draw the player with lines
            .add_component(Render::new(PLAYER_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();

        // Create Enemy with components
        io.create_entity()
            // Add the transform component for movement, firing, and displaying
            .add_component(
                // Add the default transform component
                Transform::default()
                    // Set the top middle of the screen as the initial position
                    .with_position(Vec3::new(0.0, 50.0, 0.0))
                    // Set the initial rotation to be facing towards to the player based on the camera angle
                    // (no needed if you create the object facing a different direction or differen angle rotation)
                    .with_rotation(Quat::from_euler(EulerRot::XYZ, 90., 0., 0.)),
            )
            // Add the render component to draw the enemy with lines
            .add_component(Render::new(ENEMY_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();

        // Create the Window entity with components
        io.create_entity()
            // Add the transform component for displaying the window
            .add_component(Transform::default())
            // Add the render component to draw the window with lines
            .add_component(Render::new(WINDOW_SIZE_HANDLE).primitive(Primitive::Lines))
            // Add the synchronized component to synchronize the entity with the client side
            .add_component(Synchronized)
            // Build the entity
            .build();
    Self
    }
}

// Defines entry points for the engine to hook into.
// Calls new() for the appropriate state.
make_app_state!(ClientState, ServerState);
<span class="boring">}</span></code></pre></pre>
<p>By having this code, you should get something similar like the following.</p>
<p><img src="Complete_view_of_object_creation.png" alt="Complete Object Creation Galaga View" /></p>
<p>The bottom object in the screen is the player whereas the red object that is near the top of the screen is the enemy. It does not have to be the same shape, but if each object is define as player and enemy, then we are good shape.</p>
<p>If you are not getting similar view, then please let us know so that we can help you out. Otherwise, we are ready to move to the next section.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Beginner_Tutorial/understanding_the_plugin_template.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../Beginner_Tutorial/adding_object_behaviors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Beginner_Tutorial/understanding_the_plugin_template.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../Beginner_Tutorial/adding_object_behaviors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
